[["index.html", "Manitou Experimental Forest UAS Mission Data Summary Section 1 Introduction", " Manitou Experimental Forest UAS Mission Data Summary George Woolsey 18 September, 2024 Section 1 Introduction This project summarizes processed point cloud data created using structure from motion (SfM) photogrammetry methods on imagery collected from Unmanned Aircraft System (UAS) flights completed in June 2024. UAS imagery was collected using a DJI Phantom 4 Pro equipped with a 20 megapixel metal oxide semiconductor red-green-blue camera at a fixed 8.8 mm focal length. Flights followed a pre-programmed serpentine flight paths at an altitude of 120 m above ground level, using a nadir camera orientation, with 80% forward and side image overlap.The UAV imagery was processed in Agisoft Metashape using the routine outlined by Tinkham and Swayze (2021) to produce an SfM point cloud for optimized tree detection. The SfM-derived point cloud was processed using the methods outlined by Swayze and Tinkham (2022). Specifically, this script which is outlined in detail at it’s parent Github repository was used to process the raw point cloud data. SfM techniques using UAS data reliably identify most tree locations and heights in open-canopied forests. However, their ability to characterize diameter at breast height (DBH) is limited to estimates of a fraction of trees within the area. SfM-derived DBH was estimated at the tree level following the methods outlined by Tinkham et al. (2022). "],["data_prep.html", "Section 2 Data Preparation 2.1 Data Load 2.2 Load orthomosaic rasters 2.3 What is this Point Cloud?", " Section 2 Data Preparation 2.1 Data Load Data loaded includes outputs from the UAS point cloud processing script: raw_las_ctg_info.gpkg, final_detected_crowns.gpkg, final_detected_tree_tops.gpkg. Also, loaded are experimental forest boundaries and timber harvest boundaries from the USFS FACTS database. # where is the processed data from point_cloud_processing_run_combine.R ? input_dir = &quot;E:\\\\UAS_Collections\\\\MacGregorRanch_202409\\\\point_cloud_processing_delivery&quot; # set output directory delivery_dir = &quot;E:\\\\UAS_Collections\\\\MacGregorRanch_202409\\\\processed&quot; dir.create(delivery_dir, showWarnings = FALSE) ### read data from point_cloud_processing #rasters dtm_rast = terra::rast(paste0(input_dir, &quot;/dtm_1m.tif&quot;)) chm_rast = terra::rast(paste0(input_dir, &quot;/chm_0.25m.tif&quot;)) # crowns = terra::rast(paste0(input_dir, &quot;/top_down_detected_tree_crowns.tif&quot;)) # las extent las_ctg_dta = sf::st_read(paste0(input_dir, &quot;/raw_las_ctg_info.gpkg&quot;)) # vectors # crown polygons crowns_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_crowns.gpkg&quot;)) %&gt;% dplyr::filter(tree_height_m &gt;= 2) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% # use the regional dbh estimate dplyr::mutate(dbh_cm = reg_est_dbh_cm) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # tree top points treetops_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_tree_tops.gpkg&quot;)) %&gt;% dplyr::filter(tree_height_m &gt;= 2) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% # use the regional dbh estimate dplyr::mutate(dbh_cm = reg_est_dbh_cm) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # height range for use in estimation height_range = dplyr::tibble( tree_height_m = seq( from = 0 , to = round(max(treetops_sf_with_dbh$tree_height_m)*1.05,0) , by = 0.1 # by 0.1 m increments ) ) # stand stand_sf = sf::read_sf(paste0(input_dir, &quot;/MacGregor_UAS_Flight_Boundary.kml&quot;)) %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% sf::st_transform(crs = sf::st_crs(las_ctg_dta)) %&gt;% sf::st_buffer(-5) # set crs proj_crs = sf::st_crs(las_ctg_dta) Define a function to convert columns in data frame from metric to imperial calc_imperial_units_fn &lt;- function(df) { df %&gt;% # convert to imperial units dplyr::mutate( dplyr::across( .cols = tidyselect::ends_with(&quot;_cm&quot;) , ~ .x * 0.394 , .names = &quot;{.col}_in&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m&quot;) , ~ .x * 3.28 , .names = &quot;{.col}_ft&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 4.359 , .names = &quot;{.col}_ftac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_per_ha&quot;) &amp; !tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 0.405 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_area_ha&quot;) , ~ .x * 2.471 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2&quot;) , ~ .x * 10.764 , .names = &quot;{.col}_ft2&quot; ) ) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_cm_in&quot;) ~ stringr::str_replace(x,&quot;_cm_in&quot;,&quot;_in&quot;) , stringr::str_ends(x,&quot;_m_ft&quot;) ~ stringr::str_replace(x,&quot;_m_ft&quot;,&quot;_ft&quot;) , stringr::str_ends(x,&quot;_m2_per_ha_ftac&quot;) ~ stringr::str_replace(x,&quot;_m2_per_ha_ftac&quot;,&quot;_ft2_per_ac&quot;) , stringr::str_ends(x,&quot;_per_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_per_ha_ac&quot;,&quot;_per_ac&quot;) , stringr::str_ends(x,&quot;_area_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_area_ha_ac&quot;,&quot;_area_ac&quot;) , stringr::str_ends(x,&quot;_m2_ft2&quot;) ~ stringr::str_replace(x,&quot;_m2_ft2&quot;,&quot;_ft2&quot;) , TRUE ~ x )} ) } apply the imperial calculation function crowns_sf_with_dbh = crowns_sf_with_dbh %&gt;% calc_imperial_units_fn() treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% calc_imperial_units_fn() Check the area of the stand and the flight dplyr::bind_rows( stand_sf %&gt;% dplyr::mutate(boundary_area_ha = sf::st_area(.) %&gt;% as.numeric() %&gt;% `/`(10000)) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::select(tidyselect::starts_with(&quot;boundary_area&quot;)) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate(area = &quot;stand&quot;) , las_ctg_dta %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(boundary_area_ha = sf::st_area(.) %&gt;% as.numeric() %&gt;% `/`(10000)) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::select(tidyselect::starts_with(&quot;boundary_area&quot;)) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate(area = &quot;flight&quot;) ) %&gt;% dplyr::relocate(area) %&gt;% dplyr::mutate( dplyr::across( tidyselect::where(is.numeric) , ~ scales::comma(.x, accuracy = 0.1) ) ) %&gt;% kableExtra::kbl() %&gt;% kableExtra::kable_styling() area boundary_area_ha boundary_area_ac stand 9.0 22.2 flight 24.2 59.8 2.2 Load orthomosaic rasters Orthomosaic tif files from the UAS flight imagery that were created in Agisoft Metashape are loaded and stitched together via terra::mosaic. # read list of orthos ortho_list_temp = list.files(input_dir, pattern = &quot;[^/]*ortho[^/]*\\\\.(tif|tiff)$&quot;, full.names = T)[] %&gt;% purrr::map(function(x){terra::rast(x)}) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(20) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ####### ensure the resolution of the rasters matches # terra::res(ortho_list_temp[[1]]) ## function change_res_fn = function(r, my_res=1){ r2 = r terra::res(r2) = my_res r2 = terra::resample(r, r2) return(r2) } ## apply the function ortho_list_temp = 1:length(ortho_list_temp) %&gt;% purrr::map(function(x){change_res_fn(ortho_list_temp[[x]], my_res=0.25)}) # terra::res(ortho_list_temp[[1]]) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(2) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ######## mosaic the raster list ortho_rast = terra::mosaic( terra::sprc(ortho_list_temp) , fun = &quot;min&quot; # min only thing that works ) # ortho_rast %&gt;% # terra::aggregate(4) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;lin&quot;, colNA = &quot;transparent&quot;) 2.2.1 Plot Orthomosaic from UAS Let’s define a function to plot our orthomosaic ###################################################################################### # function to plot ortho + stand ###################################################################################### ortho_plt_fn = function(stand = las_ctg_dta %&gt;% sf::st_union() %&gt;% sf::st_as_sf()){ # convert to stars ortho_st &lt;- ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( stand %&gt;% sf::st_buffer(20) %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # return(plt_rgb) # combine all plot elements plt_combine = plt_rgb + geom_sf( data = stand , alpha = 0 , lwd = 1.5 , color = &quot;gray22&quot; ) + theme( legend.position = &quot;top&quot; # c(0.5,1) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8) , legend.key = element_rect(fill = &quot;white&quot;) # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) , plot.title = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;) , plot.subtitle = element_text(size = 8, hjust = 0.5, face = &quot;italic&quot;) ) return(plt_combine) } take it for a spin ortho_plt_fn( stand = las_ctg_dta %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% sf::st_buffer(-200) ) 2.3 What is this Point Cloud? Let’s check out the raw point cloud real quick. We’ll load the raw las file generated via the Agisoft Metashape SfM algorithm. Notice the filter argument in the lidR::readLAS call to decimate the point cloud which we then keep only a region of interest using lidR::clip_roi First, we’ll define our region of interest stand_temp = dplyr::tibble(x = 454000, y = 4471990) %&gt;% sf::st_as_sf(coords = c(&quot;x&quot;,&quot;y&quot;), crs = sf::st_crs(las_ctg_dta)) %&gt;% sf::st_buffer(50, endCapStyle = &quot;SQUARE&quot;) # check it with the ortho ortho_plt_fn(stand = stand_temp) # read in las las_temp = list.files(&quot;E:\\\\UAS_Collections\\\\MacGregorRanch_202409&quot;, pattern = &quot;*\\\\.(las|laz)$&quot;, full.names = T)[1] %&gt;% lidR::readLAS(filter = &quot;-keep_random_fraction 0.6&quot;) %&gt;% lidR::clip_roi(stand_temp) what is this data? # what is this data? las_temp@data %&gt;% dplyr::glimpse() ## Rows: 2,283,188 ## Columns: 18 ## $ X &lt;dbl&gt; 453950.6, 453950.4, 453950.8, 453950.2, 453950.7, 45… ## $ Y &lt;dbl&gt; 4472039, 4472040, 4472040, 4472040, 4472040, 4472039… ## $ Z &lt;dbl&gt; 2359.812, 2360.000, 2359.811, 2360.045, 2359.813, 23… ## $ Intensity &lt;int&gt; 46774, 46003, 46774, 41891, 42148, 40606, 46260, 454… ## $ ReturnNumber &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ NumberOfReturns &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ ScanDirectionFlag &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ EdgeOfFlightline &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Classification &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Synthetic_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Keypoint_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Withheld_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ ScanAngleRank &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ UserData &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ PointSourceID &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ R &lt;int&gt; 49344, 48830, 49344, 44461, 44718, 43433, 47545, 483… ## $ G &lt;int&gt; 47031, 46260, 47031, 41891, 42405, 40349, 46517, 457… ## $ B &lt;int&gt; 40092, 37522, 39835, 35980, 35209, 34952, 41891, 380… We can plot the point cloud with RGB if the spectral information was exported from the SfM software lidR::plot(las_temp, color = &quot;RGB&quot;, bg = &quot;white&quot;, legend = F) make a gif library(magick) if(!file.exists(paste0(delivery_dir, &quot;/ptcld_rgb.gif&quot;))){ rgl::close3d() lidR::plot(las_temp, color = &quot;RGB&quot;, bg = &quot;white&quot;, legend = F) rgl::movie3d( rgl::spin3d(), duration = 10, fps = 10 , movie = &quot;ptcld_rgb&quot;, dir = delivery_dir) rgl::close3d() } Things get fun when we view X and Y data in combination with Z data. The lidR::plot function allows for plotting powered by the rgl package to provide a versatile and interactive 3D viewer of points. The argument breaks enables to defined more adequate breaks in the color palette for example when intensity contains large outliers. lidR::plot(las_temp , color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) Here we will also plot with the DTM that we generated via the UAS point cloud processing script using lidR::add_dtm3d p_temp = lidR::plot(las_temp , color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) # add dtm to plot lidR::add_dtm3d( x = p_temp , dtm = dtm_rast %&gt;% terra::crop( stand_temp %&gt;% sf::st_buffer(20) %&gt;% terra::vect() %&gt;% terra::project(terra::crs(dtm_rast)) ) %&gt;% terra::mask( stand_temp %&gt;% sf::st_buffer(20) %&gt;% terra::vect() %&gt;% terra::project(terra::crs(dtm_rast)) ) %&gt;% terra::focal( w = 3 , fun = &quot;mean&quot; , na.rm = T , na.policy = &quot;only&quot; ) ) Notice how the point altitudes are in meters above sea level. We can quickly normalize the point cloud using the DTM. nlas_temp = las_temp - dtm_rast # plot it lidR::plot(nlas_temp , color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) let’s get rid of all the ground points to focus on possible vegetation points nlas_temp %&gt;% lidR::filter_poi(Z&gt;=0.01) %&gt;% lidR::plot(color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) and let’s make a gif if(!file.exists(paste0(delivery_dir, &quot;/ptcld_z.gif&quot;))){ rgl::close3d() nlas_temp %&gt;% lidR::filter_poi(Z&gt;=0.01) %&gt;% lidR::plot(color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = F , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) rgl::movie3d( rgl::spin3d(), duration = 10, fps = 10 , movie = &quot;ptcld_z&quot;, dir = delivery_dir) rgl::close3d() } "],["tree_spatial.html", "Section 3 UAS Tree Spatial Arrangement and ICO Example 3.1 Example Tree Clump Grouping 3.2 ICO Implementation", " Section 3 UAS Tree Spatial Arrangement and ICO Example In this section, we’ll outline the steps needed to start with a UAS tree list, identify tree clump grouping, set prescription targets and generate cut/leave trees to define a prescription. 3.1 Example Tree Clump Grouping Let’s go through the tree clump grouping process for a single stand ######################### ######################### # what is overstory? ######################### ######################### #!!!!! fill in one...if both filled in will use DBH # determine overstory by height ostory_ht_m = as.numeric(NA) # m = ft / 3.281 # determine overstory by diameter ostory_dbh_cm = 6*2.54 # cm = in * 2.54 ######################### ######################### # clump spacing ######################### ######################### # maximum distance between trees for determining tree clumps # stems within 6 m of one another were considered to have the potential for developing interlocking crowns tree_clump_dist_m = 6 Check the stand location # where is this mapview::mapview( stand_sf , layer.name = &quot;stand&quot;, label = FALSE, legend = FALSE, popup = FALSE ) stand + orthomosaic # PLOT IT ortho_plt_fn(stand = stand_sf) + labs( subtitle = &quot;\\nstand boundary\\n&quot; # subtitle = &quot;&lt;span style=&#39;color:gray22;&#39;&gt;&lt;b&gt;&lt;i&gt;stand boundary&lt;/i&gt;&lt;/b&gt;&lt;/span&gt;&quot; ) + theme( plot.subtitle = element_text(size = 9.5, color = &quot;gray22&quot;, hjust = 0.5, face = &quot;bold&quot;) ) # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_01.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) we obtained a DTM from the point cloud which was used to height-normalize the point cloud # dtm dtm_temp = dtm_rast %&gt;% terra::crop( stand_sf %&gt;% terra::vect() ) %&gt;% terra::mask( stand_sf %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% `*`(3.281) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) # plot it plt_dtm_temp = ortho_plt_fn(stand = stand_sf) + # dtm ggnewscale::new_scale_fill() + geom_tile( data = dtm_temp , mapping = aes(x = x, y = y, fill = f) , na.rm = T ) + harrypotter::scale_fill_hp(&quot;hufflepuff&quot;, alpha = 0.85, labels = scales::comma) + labs(fill = &quot;DTM (ft)&quot;) + theme( legend.text = element_text(size = 5.5, angle = 40, hjust = 0.7) ) # PLOT IT plt_dtm_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_02.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) plot with CHM # chm chm_temp = chm_rast %&gt;% terra::crop( stand_sf %&gt;% terra::vect() ) %&gt;% terra::mask( stand_sf %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% `*`(3.281) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) # plot it plt_chm_temp = ortho_plt_fn(stand = stand_sf) + # chm ggnewscale::new_scale_fill() + geom_tile( data = chm_temp , mapping = aes(x = x, y = y, fill = f) , na.rm = T ) + harrypotter::scale_fill_hp(&quot;gryffindor&quot;, alpha = 0.85) + labs(fill = &quot;CHM (ft)&quot;) # PLOT IT plt_chm_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_03.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) 3.1.1 ITD individual tree crowns and heights detected from UAS-SfM plt_crowns1 &lt;- ortho_plt_fn(stand = stand_sf) + # treetops ggnewscale::new_scale_fill() + geom_sf( data = crowns_sf_with_dbh %&gt;% dplyr::inner_join( treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID) ) , mapping = aes(fill = tree_height_ft) , color = &quot;gray55&quot; , lwd = 0.3 ) + harrypotter::scale_fill_hp(&quot;gryffindor&quot;, alpha = 0.85, limits = c(4,85)) + labs(fill = &quot;Individual Tree\\nHt. (ft)&quot;) plt_crowns1 # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_04.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) individual tree top points and height detected from UAS-SfM plt_ttops_temp = ortho_plt_fn(stand = stand_sf) + # treetops geom_sf( data = treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) , mapping = aes(color = tree_height_ft) , size = 1.6 ) + harrypotter::scale_color_hp(&quot;gryffindor&quot;) + labs(color = &quot;Individual Tree\\nHt. (ft)&quot;) # PLOT IT plt_ttops_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_05.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) overstory/understory trees plt_ttops_temp = ortho_plt_fn(stand = stand_sf) + # treetops geom_sf( data = treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) %&gt;% dplyr::mutate( ostory = dplyr::case_when( !is.na(as.numeric(ostory_dbh_cm)) &amp; dbh_cm&gt;=as.numeric(ostory_dbh_cm) ~ &quot;overstory&quot; , !is.na(as.numeric(ostory_ht_m)) &amp; tree_height_m&gt;=as.numeric(ostory_ht_m) ~ &quot;overstory&quot; , is.na(as.numeric(ostory_dbh_cm)) &amp; is.na(as.numeric(ostory_ht_m)) &amp; dbh_cm&gt;=5*2.54 ~ &quot;overstory&quot; , T ~ &quot;understory&quot; ) , ostory_sz = ifelse(ostory==&quot;overstory&quot;,0.51,0.5) ) , mapping = aes(color = ostory) , size = 1.6 ) + harrypotter::scale_color_hp_d(&quot;gryffindor&quot;, direction = -1) + labs(color = &quot;&quot;) + theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) + guides(size = &quot;none&quot;, color = guide_legend(override.aes = list(size = 5))) # PLOT IT plt_ttops_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_06.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) 3.1.2 Tree Groups Identify tree groups using dbscan::dbscan() as outlined by Hanna et al. (2024): To evaluate the ability of UAS-extracted trees to characterize horizontal and vertical heterogeneity tree arrangement, clusters of trees were identifed within the stem-mapped and UAS trees. A cluster of trees was defned as two or more trees with the potential for interlocking crowns. Overstory trees on the stem maps generally had a crown radius of ~3.0 m, so stems within 6 m of one another were considered to have the potential for developing interlocking crowns. Density-based spatial clustering of applications with noise (DBSCAN) from the fpr package (Hahsler et al., 2019) in R was used to assign trees to unique clusters, including individual trees that were assigned by themselves if they did not have the potential to develop interlocking crowns (&gt;6 m from another tree). (p. 529) To analyze the efect of tree aggregation on tree attributes, the identifed trees and clusters were designated as an “individual” or as a cluster consisting of 2-4, 5-9, 10-15, and &gt;15 trees. We then calculated the number of clusters, the percent of stand basal area, the height coefcient of variation, and the canopy area within the cluster size classes for each site. (p. 529-530) With respect to clump size groupings, Churchill et al. (2016) note that: Proportions for clump sizes should be lumped into four or five bins for operational simplicity. We use 4 or 5 bins (Fig 5): individual trees, small clumps (2-4 trees), medium clumps (5-9 trees), and large clumps (10-20+ trees). Note that when instructed to leave a large clump (e.g. 10-20 trees), marking crews often have difficulty leaving the upper end of the size range (e.g. an 18, 19, or 20 tree clump). Thus adding a fifth bin for “super clumps” may be necessary (e.g. 15-20 trees or 20-25+ trees), especially if the upper size range of clumps is desired. (p. 12-13) # filter trees spatially based on unit id ttops_temp = treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) %&gt;% dplyr::mutate( ostory = dplyr::case_when( !is.na(as.numeric(ostory_dbh_cm)) &amp; dbh_cm&gt;=as.numeric(ostory_dbh_cm) ~ &quot;overstory&quot; , !is.na(as.numeric(ostory_ht_m)) &amp; tree_height_m&gt;=as.numeric(ostory_ht_m) ~ &quot;overstory&quot; , is.na(as.numeric(ostory_dbh_cm)) &amp; is.na(as.numeric(ostory_ht_m)) &amp; dbh_cm&gt;=5*2.54 ~ &quot;overstory&quot; , T ~ &quot;understory&quot; ) ) %&gt;% dplyr::filter(ostory==&quot;overstory&quot;) %&gt;% dplyr::mutate( X = sf::st_coordinates(.)[,1] %&gt;% as.numeric() , Y = sf::st_coordinates(.)[,2] %&gt;% as.numeric() ) ############################################################################# ##### Identify clusters in each stem map plot ##### ############################################################################# ### Place trees into clusters using an inter-tree distance of 6 m my_dbscan_temp = ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(X,Y) %&gt;% dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2) # my_dbscan_temp %&gt;% str() ### append cluster ID to trees ttops_temp$dbscan_cluster = my_dbscan_temp$cluster # ttops_temp$cluster %&gt;% summary() # ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(cluster) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n=11) ### cluster metrics ttops_temp = ttops_temp %&gt;% dplyr::group_by(dbscan_cluster) %&gt;% dplyr::mutate( # unique dbscan_cluster for individuals clump_id = dplyr::case_when( dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number() , T ~ dbscan_cluster ) %&gt;% factor() ) %&gt;% dplyr::group_by(clump_id) %&gt;% dplyr::mutate( dbscan_cluster = factor(dbscan_cluster) , clump_n_trees = dplyr::n() , clump_n_trees_grp = cut( clump_n_trees , breaks = c(0,1,4,9,15,25,Inf) # where to break the clump size groups , labels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) # what to name the clump size groups ) %&gt;% factor( ordered = T , levels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) # what to name the clump size groups ) ) %&gt;% dplyr::ungroup() # what? ttops_temp %&gt;% dplyr::glimpse() ## Rows: 407 ## Columns: 39 ## $ treeID &lt;chr&gt; &quot;105_454005.9_4472005.6&quot;, &quot;107_454014.1_4472… ## $ tree_height_m &lt;dbl&gt; 12.319, 13.767, 16.713, 18.059, 15.400, 14.4… ## $ crown_area_m2 &lt;dbl&gt; 15.1875, 14.5000, 26.5625, 11.5000, 17.0625,… ## $ comp_trees_per_ha &lt;dbl&gt; 254.7643, 509.5286, 382.1465, 509.5286, 382.… ## $ comp_relative_tree_height &lt;dbl&gt; 77.27872, 82.37301, 100.00000, 97.74302, 84.… ## $ comp_dist_to_nearest_m &lt;dbl&gt; 4.506939, 2.500000, 2.500000, 2.500000, 2.75… ## $ mean_crown_ht_m &lt;dbl&gt; 10.770600, 11.273027, 13.292375, 13.898620, … ## $ median_crown_ht_m &lt;dbl&gt; 11.446000, 11.748157, 13.908000, 13.442000, … ## $ min_crown_ht_m &lt;dbl&gt; 6.277000, 5.790000, 6.430000, 9.147125, 3.85… ## $ reg_est_dbh_cm &lt;dbl&gt; 22.03351, 25.57045, 32.89821, 36.49830, 29.5… ## $ reg_est_lower_dbh_cm &lt;dbl&gt; 12.067496, 14.056533, 18.049590, 20.113466, … ## $ reg_est_upper_dbh_cm &lt;dbl&gt; 34.58112, 39.68120, 51.54354, 56.85690, 45.9… ## $ is_training_data &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ dbh_cm &lt;dbl&gt; 22.03351, 25.57045, 32.89821, 36.49830, 29.5… ## $ dbh_m &lt;dbl&gt; 0.2598654, 0.2931341, 0.3730744, 0.4162416, … ## $ radius_m &lt;dbl&gt; 0.12993271, 0.14656707, 0.18653721, 0.208120… ## $ basal_area_m2 &lt;dbl&gt; 0.05303796, 0.06748740, 0.10931527, 0.136075… ## $ reg_est_dbh_in &lt;dbl&gt; 8.681202, 10.074757, 12.961896, 14.380331, 1… ## $ reg_est_lower_dbh_in &lt;dbl&gt; 4.754593, 5.538274, 7.111539, 7.924705, 6.51… ## $ reg_est_upper_dbh_in &lt;dbl&gt; 13.62496, 15.63439, 20.30815, 22.40162, 18.1… ## $ dbh_in &lt;dbl&gt; 8.681202, 10.074757, 12.961896, 14.380331, 1… ## $ tree_height_ft &lt;dbl&gt; 40.40632, 45.15576, 54.81864, 59.23352, 50.5… ## $ comp_dist_to_nearest_ft &lt;dbl&gt; 14.782760, 8.200000, 8.200000, 8.200000, 9.0… ## $ mean_crown_ht_ft &lt;dbl&gt; 35.32757, 36.97553, 43.59899, 45.58748, 43.5… ## $ median_crown_ht_ft &lt;dbl&gt; 37.54288, 38.53396, 45.61824, 44.08976, 46.3… ## $ min_crown_ht_ft &lt;dbl&gt; 20.58856, 18.99120, 21.09040, 30.00257, 12.6… ## $ dbh_ft &lt;dbl&gt; 0.8523585, 0.9614800, 1.2236841, 1.3652723, … ## $ radius_ft &lt;dbl&gt; 0.4261793, 0.4807400, 0.6118420, 0.6826362, … ## $ comp_trees_per_ac &lt;dbl&gt; 103.17954, 206.35908, 154.76931, 206.35908, … ## $ crown_area_ft2 &lt;dbl&gt; 163.47825, 156.07800, 285.91875, 123.78600, … ## $ basal_area_ft2 &lt;dbl&gt; 0.5709006, 0.7264344, 1.1766695, 1.4647195, … ## $ geom &lt;POINT [m]&gt; POINT (454005.9 4472006), POINT (45401… ## $ ostory &lt;chr&gt; &quot;overstory&quot;, &quot;overstory&quot;, &quot;overstory&quot;, &quot;over… ## $ X &lt;dbl&gt; 454005.9, 454014.1, 454016.1, 454051.6, 4540… ## $ Y &lt;dbl&gt; 4472006, 4472004, 4472003, 4471997, 4471994,… ## $ dbscan_cluster &lt;fct&gt; 0, 1, 1, 2, 2, 0, 0, 0, 3, 3, 3, 4, 3, 4, 3,… ## $ clump_id &lt;fct&gt; 73, 1, 1, 2, 2, 74, 75, 76, 3, 3, 3, 4, 3, 4… ## $ clump_n_trees &lt;int&gt; 1, 2, 2, 2, 2, 1, 1, 1, 7, 7, 7, 8, 7, 8, 7,… ## $ clump_n_trees_grp &lt;ord&gt; Individual, 2-4 trees, 2-4 trees, 2-4 trees,… plot overstory tree clumps plt_grps_temp = ortho_plt_fn(stand = stand_sf) + # treetops geom_sf( data = ttops_temp , mapping = aes(color = dbscan_cluster) , size = 1.6 ) + scale_color_manual(values = c( &quot;white&quot; , # get random list of colors from viridis and avoid whites c( viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round()) , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.95) , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) ) %&gt;% sample() %&gt;% .[1:length(unique(ttops_temp$dbscan_cluster))-1] ) ) + # scale_color_viridis_d(&quot;turbo&quot;) + labs(subtitle = &quot;\\n overstory tree groups\\n(individual trees in white)&quot;) + theme( legend.position = &quot;none&quot; , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = &quot;bold&quot;) ) # PLOT IT plt_grps_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_07.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) and plot overstory tree clumps by number of trees plt_grps_temp = ortho_plt_fn(stand = stand_sf) + # treetops geom_sf( data = ttops_temp , mapping = aes(color = clump_n_trees_grp) , size = 1.6 ) + harrypotter::scale_color_hp_d(&quot;always&quot;, name = &quot;clump size&quot;, drop = F) + labs(color = &quot;&quot;) + theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) + guides(size = &quot;none&quot;, color = guide_legend(override.aes = list(size = 5))) # PLOT IT plt_grps_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_08.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) if we want to plot the groups with the tree crowns we can do that too plt_grps_temp = ortho_plt_fn(stand = stand_sf) + # treetops geom_sf( data = crowns_sf_with_dbh %&gt;% dplyr::inner_join( ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, clump_n_trees_grp) , by = &quot;treeID&quot; ) , mapping = aes(fill = clump_n_trees_grp) , size = 1.6 ) + harrypotter::scale_fill_hp_d(&quot;always&quot;, name = &quot;clump size&quot;, drop = F) + labs(fill = &quot;&quot;) + theme(legend.key = element_rect(fill = NA, color = NA), legend.margin = margin(6.5,0,6.5,0)) + guides(size = &quot;none&quot;, fill = guide_legend(override.aes = list(size = 5))) # PLOT IT plt_grps_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_09.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) 3.1.3 Within Clump Distance Determine nearest neighbor distance for the stand and within clusters. Some combination of these metrics has been used to describe relative aggregation. (source?) Calculate the distance to the nearest tree within each clump ttops_temp = ttops_temp %&gt;% dplyr::group_by(clump_id) %&gt;% tidyr::nest() %&gt;% dplyr::mutate( distance_clump_nn_m = purrr::map(data, function(x){ # get index of nearest neighbor i = sf::st_nearest_feature(x) # get dist d = sf::st_distance(x, x[i,], by_element=TRUE) %&gt;% as.numeric() return(d) }) ) %&gt;% tidyr::unnest(cols = c(data, distance_clump_nn_m)) %&gt;% sf::st_set_geometry(&quot;geom&quot;) %&gt;% # set it cuz it got lost dplyr::ungroup() # ggplot() + geom_point(aes(x=X,y=Y,color = distance_clump_nn_m)) + theme_light() plot it ortho_plt_fn(stand = stand_sf) + # treetops geom_sf( data = ttops_temp , mapping = aes(color = distance_clump_nn_m) , size = 1.6 ) + # scale_color_viridis_c(option=&quot;viridis&quot;, na.value = &quot;white&quot;) + harrypotter::scale_color_hp(&quot;hufflepuff&quot;, na.value = &quot;white&quot;) + labs(color = &quot;within clump\\nN.N. dist. (m)&quot;) 3.1.3.1 Create function to get tree list with clumps first, create a general function to apply dbscan::dbscan to point data of class sf With respect to clump size groupings, Churchill et al. (2016) note that: Proportions for clump sizes should be lumped into four or five bins for operational simplicity. We use 4 or 5 bins (Fig 5): individual trees, small clumps (2-4 trees), medium clumps (5-9 trees), and large clumps (10-20+ trees). Note that when instructed to leave a large clump (e.g. 10-20 trees), marking crews often have difficulty leaving the upper end of the size range (e.g. an 18, 19, or 20 tree clump). Thus adding a fifth bin for “super clumps” may be necessary (e.g. 15-20 trees or 20-25+ trees), especially if the upper size range of clumps is desired. (p. 12-13) In their prescription worksheet Excel file Churchill et al. (2016) have the following group sizes: 1, 2-4 (Mean clump size: 3), 5-9 (7), 10-15 (12), 16-25 (20). To be able to cut clumps down to achieve the desired largest “16-25” group, we’ll add a “super” group with &gt;25 trees. This same principle can be applied if you desire a clump size group larger than this (i.e. 25-35), whereby a group above this should be added so that the resulting prescription cuts the “super” group to ensure the proper sizing of the desired largest group. # function to clump data that are sf points st_clump_points &lt;- function( x # point data of class `sf` , clump_dist_m = 6 # size (radius) of the epsilon neighborhood = maximum distance between points to add to clump , clump_breaks = c(0,1,4,9,15,25,Inf) # where to break the clump size groups , clump_labels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) # what to name the clump size groups ) { # get points as x,y point_clusters = x %&gt;% dplyr::mutate( X = sf::st_coordinates(.)[,1] %&gt;% as.numeric() , Y = sf::st_coordinates(.)[,2] %&gt;% as.numeric() ) ############################################################################# ##### Identify clusters in each stem map plot ##### ############################################################################# ### Place trees into clusters using an inter-tree distance of 6 m my_dbscan_temp = point_clusters %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(X,Y) %&gt;% dbscan::dbscan(eps = clump_dist_m, minPts = 2) # my_dbscan_temp %&gt;% str() ### append cluster ID to tree points point_clusters$dbscan_cluster = my_dbscan_temp$cluster # point_clusters$cluster %&gt;% summary() # point_clusters %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(cluster) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n=11) ### cluster metrics point_clusters = point_clusters %&gt;% dplyr::group_by(dbscan_cluster) %&gt;% dplyr::mutate( # unique dbscan_cluster for individuals clump_id = dplyr::case_when( dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number() , T ~ dbscan_cluster ) %&gt;% factor() ) %&gt;% dplyr::group_by(clump_id) %&gt;% dplyr::mutate( dbscan_cluster = factor(dbscan_cluster) , clump_n_trees = dplyr::n() , clump_n_trees_grp = cut( clump_n_trees , breaks = clump_breaks , labels = clump_labels ) %&gt;% factor( ordered = T , levels = clump_labels ) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate(tree_clump_dist_m = clump_dist_m) # return return(point_clusters) } function specific to this project to filter the tree points attached to harvest bounds and apply the st_clump_points function # create function to pass a unit id and return list of trees with clump groupings get_tree_clumps = function( tree_clump_dist_m=6 , ostory_ht_m = as.numeric(NA) , ostory_dbh_cm = as.numeric(NA) ){ # check ostory definition if(is.na(as.numeric(ostory_dbh_cm)) &amp; is.na(as.numeric(ostory_ht_m))){ warning(&quot;`ostory_dbh_cm` and `ostory_ht_m` are not set...using `ostory_dbh_cm` = 12.7&quot;) ostory_dbh_cm = 5*2.54 # filter data ttops_temp = treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) %&gt;% dplyr::filter( dbh_cm&gt;=as.numeric(ostory_dbh_cm) ) }else if(!is.na(as.numeric(ostory_dbh_cm))){ # filter data ttops_temp = treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) %&gt;% dplyr::filter( dbh_cm&gt;=as.numeric(ostory_dbh_cm) ) }else{ # filter data ttops_temp = treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) %&gt;% dplyr::filter( tree_height_m&gt;=as.numeric(ostory_ht_m) ) } ### Place trees into clusters using an inter-tree distance of 6 m ttops_temp = st_clump_points( x = ttops_temp , clump_dist_m = tree_clump_dist_m ) # add distance to nearest within clump ttops_temp = ttops_temp %&gt;% dplyr::group_by(clump_id) %&gt;% tidyr::nest() %&gt;% dplyr::mutate( distance_clump_nn_m = purrr::map(data, function(x){ # get index of nearest neighbor i = sf::st_nearest_feature(x) # get dist d = sf::st_distance(x, x[i,], by_element=TRUE) %&gt;% as.numeric() return(d) }) ) %&gt;% tidyr::unnest(cols = c(data, distance_clump_nn_m)) %&gt;% sf::st_set_geometry(&quot;geom&quot;) %&gt;% # set it cuz it got lost dplyr::ungroup() %&gt;% dplyr::mutate( tree_clump_dist_m = tree_clump_dist_m , clump_id_duplicate = clump_id # can use this even after nesting data by clump_id # , ostory_ht_m = ifelse(is.na(ostory_ht_m), as.numeric(NA), as.numeric(ostory_ht_m)) # , ostory_dbh_cm = ifelse(is.na(ostory_dbh_cm), as.numeric(NA), as.numeric(ostory_dbh_cm)) ) # return return(ttops_temp) } # call it ttops_temp = get_tree_clumps( tree_clump_dist_m = tree_clump_dist_m , ostory_dbh_cm = ostory_dbh_cm ) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries 3.1.4 Clump Polygons and Metrics Churchill et al. (2016) provide instructions for implementing the clump identification (Plotkin et al. 2002) in ArcGIS: Use the Buffer tool (in the Proximity toolset within the Analysis toolbox) to create a buffer of distance d/2, one half the inter-tree distance, around each point. This quantity d/2 is meant to approximate the crown radius of a “typical” overstory tree. Set the Dissolve Type option to ALL, which dissolves overlapping buffers, creating a reduced set of spatially non-overlapping polygons stored as a multipart polygon feature…Sanchez Meador et al. (2011) provide some useful examples of how clump attributes can be summarized…The method described here can be modified to use measured or modeled crown radii for each tree in place of d/2 (p.36) # create function to pass a return from st_clump_points/get_tree_clumps and create clump polygons with summary stats get_clump_summary = function(dta){ # get tree_clump_dist_m tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T) # create clump polys and summary clump_polys_temp = dta %&gt;% dplyr::ungroup() %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% sf::st_buffer(tree_clump_dist_m/2) %&gt;% dplyr::group_by(clump_id, dbscan_cluster, clump_n_trees_grp) %&gt;% dplyr::summarise( # union buffered tree points geometry = sf::st_union(geometry) # summary metrics , n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) , .groups = &quot;drop_last&quot; ) %&gt;% dplyr::ungroup() %&gt;% sf::st_make_valid() %&gt;% dplyr::mutate( clump_area_ha = sf::st_area(geometry) %&gt;% as.numeric() %&gt;% `/`(10000) , trees_per_ha = (n_trees/clump_area_ha) , basal_area_m2_per_ha = (basal_area_m2/clump_area_ha) , pct_stand_basal_area = basal_area_m2/sum(basal_area_m2) , pct_stand_n_trees = n_trees/sum(n_trees) , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units calc_imperial_units_fn() %&gt;% dplyr::mutate(tree_clump_dist_m = tree_clump_dist_m) # calculate distance between clumps clump_polys_temp = clump_polys_temp %&gt;% dplyr::mutate( nearest = sf::st_nearest_feature(clump_polys_temp) , distance_nearest_clump_m = sf::st_distance( clump_polys_temp , clump_polys_temp[nearest,] , by_element=TRUE ) %&gt;% as.numeric() ) %&gt;% dplyr::select(-c(nearest)) # return return(clump_polys_temp) } # get it # get_clump_summary( # dta = get_tree_clumps(tree_clump_dist_m = tree_clump_dist_m) # ) clump_polys_temp = get_clump_summary(ttops_temp) # what? clump_polys_temp %&gt;% dplyr::glimpse() ## Rows: 140 ## Columns: 25 ## $ clump_id &lt;fct&gt; 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 8… ## $ dbscan_cluster &lt;fct&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ clump_n_trees_grp &lt;ord&gt; Individual, Individual, Individual, Individua… ## $ geometry &lt;POLYGON [m]&gt; POLYGON ((454008.9 4472006,..., POLYG… ## $ n_trees &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ mean_dbh_cm &lt;dbl&gt; 22.03351, 27.22031, 17.21324, 29.36832, 17.00… ## $ mean_tree_height_m &lt;dbl&gt; 12.319, 14.453, 10.182, 15.274, 10.106, 21.87… ## $ loreys_height_m &lt;dbl&gt; 12.319, 14.453, 10.182, 15.274, 10.106, 21.87… ## $ basal_area_m2 &lt;dbl&gt; 0.05303796, 0.07461986, 0.03733884, 0.0857277… ## $ clump_area_ha &lt;dbl&gt; 0.002826142, 0.002826142, 0.002826142, 0.0028… ## $ trees_per_ha &lt;dbl&gt; 353.8393, 353.8393, 353.8393, 353.8393, 353.8… ## $ basal_area_m2_per_ha &lt;dbl&gt; 18.76692, 26.40344, 13.21195, 30.33385, 12.89… ## $ pct_stand_basal_area &lt;dbl&gt; 0.0016285232, 0.0022911922, 0.0011464838, 0.0… ## $ pct_stand_n_trees &lt;dbl&gt; 0.002457002, 0.002457002, 0.002457002, 0.0024… ## $ qmd_cm &lt;dbl&gt; 22.03351, 27.22031, 17.21324, 29.36832, 17.00… ## $ mean_dbh_in &lt;dbl&gt; 8.681202, 10.724804, 6.782017, 11.571119, 6.6… ## $ qmd_in &lt;dbl&gt; 8.681202, 10.724804, 6.782017, 11.571119, 6.6… ## $ mean_tree_height_ft &lt;dbl&gt; 40.40632, 47.40584, 33.39696, 50.09872, 33.14… ## $ loreys_height_ft &lt;dbl&gt; 40.40632, 47.40584, 33.39696, 50.09872, 33.14… ## $ basal_area_ft2_per_ac &lt;dbl&gt; 81.80499, 115.09259, 57.59089, 132.22525, 56.… ## $ trees_per_ac &lt;dbl&gt; 143.3049, 143.3049, 143.3049, 143.3049, 143.3… ## $ clump_area_ac &lt;dbl&gt; 0.006983396, 0.006983396, 0.006983396, 0.0069… ## $ basal_area_ft2 &lt;dbl&gt; 0.5709006, 0.8032082, 0.4019153, 0.9227736, 0… ## $ tree_clump_dist_m &lt;dbl&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, … ## $ distance_nearest_clump_m &lt;dbl&gt; 2.3446401, 7.3671213, 24.1966696, 3.3007035, … # do these numbers match identical( # clump polys nrow(clump_polys_temp) # clumps in tree list data , ttops_temp %&gt;% dplyr::distinct(clump_id) %&gt;% nrow() ) ## [1] TRUE plot it ortho_plt_fn(stand = stand_sf) + # clumps ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp , mapping = aes(fill = dbscan_cluster) , color = NA, alpha = 0.9 , size = 1.6 ) + scale_fill_manual(values = c( &quot;white&quot; , # get random list of colors from viridis and avoid whites c( viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round()) , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.95) , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) ) %&gt;% sample() %&gt;% .[1:length(unique(ttops_temp$dbscan_cluster))-1] ) ) + labs(subtitle = &quot;\\n overstory tree group polygons\\n(individual trees in white)&quot;) + theme( legend.position = &quot;none&quot; , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = &quot;bold&quot;) ) check the distance between clumps ortho_plt_fn(stand = stand_sf) + ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp , mapping = aes(fill = distance_nearest_clump_m) , size = 1.6, color = NA ) + harrypotter::scale_fill_hp(&quot;mischief&quot;, direction = -1) + labs(fill = &quot;nearest clump\\ndist. (m)&quot;) and plot the clump group size ortho_plt_fn(stand = stand_sf) + ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp , mapping = aes(fill = clump_n_trees_grp) , size = 1.6, color = NA ) + harrypotter::scale_fill_hp_d(&quot;always&quot;, name = &quot;clump size&quot;, drop = F) + labs(fill = &quot;&quot;) + theme(legend.key = element_rect(fill = NA, color = NA), legend.margin = margin(6.5,0,6.5,0)) + guides(size = &quot;none&quot;, fill = guide_legend(override.aes = list(size = 5))) 3.1.5 Clump Spacing See Churchill et al. (2016) Figure 4 (p.10) and Matonis and Binkley (2018) who “calculated coverage of mosaic-meadows (percentage of stand &gt; 6 m from overstory trees)” (p. 124) Since we already buffered the tree points to approximate the crown radius, we’ll continue to use our \\(d/2\\) where \\(d\\) is maximum distance between trees for determining tree clumps and is meant to approximate the crown radius of a “typical” overstory tree # create function to pass a return from get_clump_summary() and get a distance raster get_clump_dist_rast = function(dta){ # get tree_clump_dist_m tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T) # rasterize the clump polygons and then calculate distance between clumps as raster dist_rast = terra::rasterize( x = dta %&gt;% terra::vect() , y = dta %&gt;% terra::vect() %&gt;% terra::rast(res = 0.2) ) %&gt;% terra::distance() %&gt;% # crop it to stand extent terra::crop( stand_sf %&gt;% terra::vect() ) %&gt;% terra::mask( stand_sf %&gt;% terra::vect() ) ######### part 2 # now create openings vector data openings_vect = dist_rast %&gt;% terra::classify(rcl = c(tree_clump_dist_m/2,Inf), others = NA, include.lowest = T) %&gt;% terra::as.polygons(na.rm = T) %&gt;% sf::st_as_sf() %&gt;% sf::st_cast(&quot;POLYGON&quot;) %&gt;% dplyr::mutate(layer = dplyr::row_number()) %&gt;% dplyr::mutate( openining_area_m2 = sf::st_area(geometry) %&gt;% as.numeric() , tree_clump_dist_m = tree_clump_dist_m ) # return return(list(dist_rast = dist_rast, openings_vect = openings_vect)) } # get it dist_rast_temp = get_clump_dist_rast(clump_polys_temp) dist_rast_temp ## $dist_rast ## class : SpatRaster ## dimensions : 1619, 1878, 1 (nrow, ncol, nlyr) ## resolution : 0.2, 0.2 (x, y) ## extent : 453830.9, 454206.5, 4471685, 4472009 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83 / UTM zone 13N (EPSG:26913) ## source(s) : memory ## name : layer ## min value : 0.00000 ## max value : 40.85976 ## ## $openings_vect ## Simple feature collection with 15 features and 3 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 453830.9 ymin: 4471685 xmax: 454206.5 ymax: 4472009 ## Projected CRS: NAD83 / UTM zone 13N ## First 10 features: ## layer geometry openining_area_m2 tree_clump_dist_m ## 1 1 POLYGON ((454020.1 4471861,... 0.04 6 ## 1.1 2 POLYGON ((454018.7 4471860,... 0.04 6 ## 1.2 3 POLYGON ((454018.5 4471859,... 9.40 6 ## 1.3 4 POLYGON ((454018.7 4471829,... 0.04 6 ## 1.4 5 POLYGON ((453876.1 4471809,... 0.04 6 ## 1.5 6 POLYGON ((453873.5 4471806,... 0.04 6 ## 1.6 7 POLYGON ((453880.1 4471781,... 0.08 6 ## 1.7 8 POLYGON ((453864.9 4471764,... 0.04 6 ## 1.8 9 POLYGON ((453903.9 4471762,... 0.04 6 ## 1.9 10 POLYGON ((453894.3 4471762,... 0.04 6 plot the distance raster and openings vector data we just got with overlaid tree clumps and tree points plt_fnl_temp = ggplot() + # distance geom_tile( data = dist_rast_temp$dist_rast %&gt;% terra::aggregate(2, cores = 4) %&gt;% as.data.frame(xy = T) %&gt;% rename(f=3) , mapping = aes(x=x, y=y, fill = f) ) + harrypotter::scale_fill_hp( &quot;mischief&quot; , na.value = &quot;transparent&quot; , name = &quot;distance to\\nnearest tree (m)&quot; , limits = c(0,45) ) + # openings geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(color = openining_area_m2), fill = NA) + scale_color_gradient( low = &quot;gray77&quot;, high = &quot;gray11&quot; , labels = scales::comma_format(accuracy = 1) , name = latex2exp::TeX(&quot;opening\\narea ($\\\\m^2$)&quot;) , limits = c(0,70000) ) + # clumps ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp , mapping = aes(fill = clump_n_trees_grp) , color = NA ) + harrypotter::scale_fill_hp_d(&quot;always&quot;, name = &quot;clump size&quot;, drop = F) + # tree points geom_sf(data = ttops_temp, color = &quot;gray88&quot;, shape = &quot;.&quot;) + theme_void() + theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) # plot plt_fnl_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_10.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) highlight the openings plt_open_temp = ggplot() + # clumps geom_sf( data = clump_polys_temp , mapping = aes(fill = clump_n_trees_grp) , color = NA ) + harrypotter::scale_fill_hp_d(&quot;always&quot;, name = &quot;clump size&quot;, drop = F) + # openings ggnewscale::new_scale_fill() + geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(fill = openining_area_m2), color = NA) + scale_fill_gradient( low = &quot;gray77&quot;, high = &quot;gray11&quot; , labels = scales::comma_format(accuracy = 1) , name = latex2exp::TeX(&quot;opening\\narea ($\\\\m^2$)&quot;) , limits = c(0,70000) ) + # tree points geom_sf(data = ttops_temp, color = &quot;gray88&quot;, shape = &quot;.&quot;) + theme_void() + theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) # plot plt_open_temp combine them? plt_fnl_temp + (plt_open_temp + theme(legend.position = &quot;none&quot;)) &amp; theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) 3.1.6 Clump Metrics create a function to summarize by number of tree clump grouping variable # create a function to summarize by number of tree clump grouping get_clump_n_trees_grp_summary = function(trees, clumps){ # get area of harvest unit #...will use this area in the area calculations such that... #...TPA = trees in a certain group size across the whole stand area harvest_area_ha = stand_sf %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(harvest_area_ha = sf::st_area(.) %&gt;% as.numeric() %&gt;% `/`(10000)) %&gt;% dplyr::pull(harvest_area_ha) %&gt;% .[1] # collapse and calculate silv metrics dta = trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate(stand_area_ha = harvest_area_ha) %&gt;% dplyr::group_by(stand_area_ha,clump_n_trees_grp) %&gt;% dplyr::summarise( # summary metrics n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) , .groups = &quot;drop_last&quot; ) %&gt;% dplyr::ungroup() %&gt;% # attach clump area dplyr::left_join( clumps %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(clump_n_trees_grp) %&gt;% dplyr::summarise( clump_area_ha = sum(clump_area_ha) , stand_n_clumps = dplyr::n() , .groups = &quot;drop_last&quot; ) %&gt;% dplyr::ungroup() , by = dplyr::join_by(clump_n_trees_grp) ) %&gt;% dplyr::mutate( trees_per_ha = (n_trees/stand_area_ha) # (n_trees/clump_area_ha) ... this was not right , basal_area_m2_per_ha = (basal_area_m2/stand_area_ha) # (basal_area_m2/clump_area_ha) ... this was not right , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) # stand calcs , stand_trees_per_ha = sum(n_trees)/stand_area_ha , stand_basal_area_m2 = sum(basal_area_m2) , stand_basal_area_m2_per_ha = sum(basal_area_m2)/stand_area_ha , pct_stand_basal_area = basal_area_m2/stand_basal_area_m2 , pct_stand_n_trees = n_trees/sum(n_trees) , stand_qmd_cm = sqrt(sum(trees$dbh_cm^2, na.rm = T)/sum(n_trees)) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units calc_imperial_units_fn() # return return(dta) } # call it clump_n_trees_grp_summary_temp = get_clump_n_trees_grp_summary( trees = get_tree_clumps(tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm) , clumps = get_clump_summary( get_tree_clumps(tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm) ) ) # what? clump_n_trees_grp_summary_temp %&gt;% dplyr::glimpse() ## Rows: 5 ## Columns: 31 ## $ stand_area_ha &lt;dbl&gt; 8.991271, 8.991271, 8.991271, 8.991271, 8.… ## $ clump_n_trees_grp &lt;ord&gt; Individual, 2-4 trees, 5-9 trees, 10-15 tr… ## $ n_trees &lt;int&gt; 68, 134, 86, 42, 77 ## $ mean_dbh_cm &lt;dbl&gt; 27.99178, 27.00273, 24.49694, 20.37825, 26… ## $ mean_tree_height_m &lt;dbl&gt; 14.61024, 14.26002, 13.21962, 11.56174, 14… ## $ loreys_height_m &lt;dbl&gt; 17.40696, 15.97270, 14.96544, 12.04327, 15… ## $ basal_area_m2 &lt;dbl&gt; 6.694974, 11.491299, 6.026900, 2.123237, 6… ## $ clump_area_ha &lt;dbl&gt; 0.19217763, 0.30282975, 0.16399426, 0.0713… ## $ stand_n_clumps &lt;int&gt; 68, 51, 14, 3, 4 ## $ trees_per_ha &lt;dbl&gt; 7.562891, 14.903344, 9.564833, 4.671197, 8… ## $ basal_area_m2_per_ha &lt;dbl&gt; 0.7446082, 1.2780506, 0.6703057, 0.2361443… ## $ qmd_cm &lt;dbl&gt; 29.69610, 28.00751, 25.65050, 20.70925, 27… ## $ stand_trees_per_ha &lt;dbl&gt; 45.26613, 45.26613, 45.26613, 45.26613, 45… ## $ stand_basal_area_m2 &lt;dbl&gt; 32.56814, 32.56814, 32.56814, 32.56814, 32… ## $ stand_basal_area_m2_per_ha &lt;dbl&gt; 3.622195, 3.622195, 3.622195, 3.622195, 3.… ## $ pct_stand_basal_area &lt;dbl&gt; 0.20556822, 0.35283871, 0.18505512, 0.0651… ## $ pct_stand_n_trees &lt;dbl&gt; 0.1670762, 0.3292383, 0.2113022, 0.1031941… ## $ stand_qmd_cm &lt;dbl&gt; 27.02183, 27.02183, 27.02183, 27.02183, 27… ## $ mean_dbh_in &lt;dbl&gt; 11.028762, 10.639077, 9.651796, 8.029032, … ## $ qmd_in &lt;dbl&gt; 11.700261, 11.034959, 10.106297, 8.159443,… ## $ stand_qmd_in &lt;dbl&gt; 10.6466, 10.6466, 10.6466, 10.6466, 10.6466 ## $ mean_tree_height_ft &lt;dbl&gt; 47.92157, 46.77287, 43.36034, 37.92250, 46… ## $ loreys_height_ft &lt;dbl&gt; 57.09484, 52.39045, 49.08666, 39.50192, 50… ## $ basal_area_ft2_per_ac &lt;dbl&gt; 3.245747, 5.571023, 2.921863, 1.029353, 3.… ## $ stand_basal_area_ft2_per_ac &lt;dbl&gt; 15.78915, 15.78915, 15.78915, 15.78915, 15… ## $ trees_per_ac &lt;dbl&gt; 3.062971, 6.035854, 3.873757, 1.891835, 3.… ## $ stand_trees_per_ac &lt;dbl&gt; 18.33278, 18.33278, 18.33278, 18.33278, 18… ## $ stand_area_ac &lt;dbl&gt; 22.21743, 22.21743, 22.21743, 22.21743, 22… ## $ clump_area_ac &lt;dbl&gt; 0.4748709, 0.7482923, 0.4052298, 0.1762996… ## $ basal_area_ft2 &lt;dbl&gt; 72.06470, 123.69234, 64.87355, 22.85453, 6… ## $ stand_basal_area_ft2 &lt;dbl&gt; 350.5634, 350.5634, 350.5634, 350.5634, 35… summary table # table it clump_n_trees_grp_summary_temp %&gt;% dplyr::select( clump_n_trees_grp, n_trees , mean_dbh_in , qmd_in , mean_tree_height_ft , loreys_height_ft , trees_per_ac , basal_area_ft2_per_ac, pct_stand_basal_area, pct_stand_n_trees ) %&gt;% dplyr::mutate( dplyr::across( .cols = c(pct_stand_basal_area, pct_stand_n_trees) , .fns = ~ scales::percent(.x, accuracy = 1) ) ) %&gt;% kableExtra::kbl( digits = 1 , escape = F , caption = paste0(&quot;Overstory tree clump summary&quot;) , col.names = c( &quot;&quot;, &quot;trees&quot; , &quot;mean&lt;br&gt;DBH (in)&quot; , &quot;QMD (in)&quot; , &quot;mean&lt;br&gt;Ht. (ft)&quot; , &quot;Loreys&lt;br&gt;Ht. (ft)&quot; , &quot;TPA&quot; , &quot;BA&lt;br&gt;ft&lt;sup&gt;2&lt;/sup&gt; ac&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;%&lt;br&gt;stand BA&quot; , &quot;%&lt;br&gt;stand trees&quot; ) ) %&gt;% kableExtra::kable_styling() Table 3.1: Overstory tree clump summary trees meanDBH (in) QMD (in) meanHt. (ft) LoreysHt. (ft) TPA BAft2 ac-1 %stand BA %stand trees Individual 68 11.0 11.7 47.9 57.1 3.1 3.2 21% 17% 2-4 trees 134 10.6 11.0 46.8 52.4 6.0 5.6 35% 33% 5-9 trees 86 9.7 10.1 43.4 49.1 3.9 2.9 19% 21% 10-15 trees 42 8.0 8.2 37.9 39.5 1.9 1.0 7% 10% 16-25 trees 77 10.4 10.8 46.1 50.8 3.5 3.0 19% 19% plot it clump_n_trees_grp_summary_temp %&gt;% dplyr::select( clump_n_trees_grp, n_trees , mean_dbh_in , qmd_in , mean_tree_height_ft , loreys_height_ft , trees_per_ac , basal_area_ft2_per_ac, pct_stand_basal_area ) %&gt;% dplyr::mutate(pct_stand_basal_area = pct_stand_basal_area*100) %&gt;% tidyr::pivot_longer( cols = -c(clump_n_trees_grp) ) %&gt;% dplyr::mutate( metric = factor( name , ordered = T , levels = c( &quot;n_trees&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;trees_per_ac&quot; , &quot;basal_area_ft2_per_ac&quot; , &quot;pct_stand_basal_area&quot; ) , labels = c( latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , latex2exp::TeX(&quot;% stand BA&quot;, output = &quot;character&quot;) ) ) , clump_n_trees_grp = forcats::fct_rev(clump_n_trees_grp) ) %&gt;% ggplot(mapping = aes( x = value, y = clump_n_trees_grp , fill = name, label = scales::number(value, accuracy = 0.1) ) ) + geom_col(width = 0.5) + geom_text(color = &quot;black&quot;, size = 3.5, hjust = -0.1) + facet_wrap(facets = vars(metric), ncol = 2, scales = &quot;free_x&quot;, labeller = label_parsed) + harrypotter::scale_fill_hp_d(&quot;lunalovegood&quot;) + scale_x_continuous(expand = expansion(mult = c(0,0.1))) + labs( x = &quot;&quot;, y = &quot;&quot; , subtitle = &quot;Overstory tree clump summary&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , strip.text = element_text(color = &quot;black&quot;, size = 10) , strip.background = element_rect(fill = &quot;gray88&quot;) , axis.text.y = element_text(face = &quot;bold&quot;) , axis.ticks.y = element_blank() , panel.grid.major.y = element_blank() , panel.grid.minor.y = element_blank() ) 3.2 ICO Implementation Churchill et al. (2016) describe the full process for implementing the ICO approach in The ICO Approach to Quantifying and Restoring Forest Spatial Pattern: Implementation Guide in which the authors lay out the prescription development process: Identify skips and other special treatment areas Consider the need for openings Determine the stand average density target Determine the appropriate distance to define clumps Obtain targets for clump proportions Select target clump proportions for your stand Generate clump targets for the whole unit Combine clump and opening targets with leave tree criteria into marking guidelines The objective here is to: 1) provide the manager with the current conditions (completed above); 2) take the “targets” as set by the manager (steps 3, 5, 6, 7); 3) create the prescription with the leave tree marking. Let’s implement this prescription development process with our UAS tree list 3.2.1 3. Determine the stand average density target Step 3 in Churchill et al. (2016): An average BA, TPA, or SDI target for the stand should be selected that is appropriate for the species, structure, site conditions, and management objectives. Expected mortality from prescribed fire should be factored in. Stand average targets can come from historical reference stands, plant association based stocking guides, density management tools, or a combination of both (see Franklin et al. (2013) for a full discussion of setting density targets). In dry forests, the number and size of old trees must be accounted in setting the density target. To use the ICO method, the target must be converted to TPA (see Table 1). A lower diameter cutoff also needs to be specified for the TPA target. This should be the lower limit in the contract or cutting guidelines given to the marking crew or contractor. (p.11) this is what Table 1 looks like with TPA values are derived from the formula: \\[ TPA = \\frac{BA}{QMD^{2} \\times 0.005454} \\] # function to get tpa from ba and qmd get_tpa = function(ba_ft2_ac, qmd_in){ tpa = round(ba_ft2_ac/((qmd_in^2)*0.005454)) return(tpa) } # table it tidyr::crossing( ba = seq(40,200,20) , qmd = seq(8,20,2) ) %&gt;% dplyr::mutate( tpa = get_tpa(ba,qmd) ) %&gt;% tidyr::pivot_wider(names_from = ba, values_from = tpa) %&gt;% dplyr::mutate(l = &quot;QMD (in)&quot;) %&gt;% dplyr::relocate(l) %&gt;% kableExtra::kbl( col.names = c(&quot;.&quot;,&quot;&quot;, seq(40,200,20)) , escape = F , caption = &quot;Basal Area and QMD to TPA conversion chart&quot; ) %&gt;% kableExtra::add_header_above( c(&quot;&quot;,&quot;&quot;, &quot;Basal Area (ft2/ac)&quot;=length(seq(40,200,20))) ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::column_spec(1:2, bold = T) %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;middle&quot;) Table 3.2: Basal Area and QMD to TPA conversion chart Basal Area (ft2/ac) . 40 60 80 100 120 140 160 180 200 QMD (in) 8 115 172 229 286 344 401 458 516 573 10 73 110 147 183 220 257 293 330 367 12 51 76 102 127 153 178 204 229 255 14 37 56 75 94 112 131 150 168 187 16 29 43 57 72 86 100 115 129 143 18 23 34 45 57 68 79 91 102 113 20 18 28 37 46 55 64 73 83 92 3.2.1.1 Current Stand Conditions For determining targets, the silviculturist needs to know the current conditions. Provide the current stand conditions based on the UAS tree list for the selected stand that are required to set the targets: Current BA Current QMD Current proportion of trees by clump size clump_n_trees_grp_summary_temp %&gt;% dplyr::select(clump_n_trees_grp, pct_stand_n_trees) %&gt;% dplyr::mutate( pct_stand_n_trees = scales::percent(pct_stand_n_trees,accuracy = 1) ) %&gt;% tidyr::pivot_wider(names_from = clump_n_trees_grp, values_from = pct_stand_n_trees) %&gt;% kableExtra::kable( caption = paste0( &quot;Current stand BA (ft2/ac): &quot; , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand QMD (in): &quot; , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand TPA: &quot; , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %&gt;% scales::number(accuracy = 1) ) , escape = F , digits = 1 ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::footnote(general = &quot;values are the percent of trees in each clump size&quot;) Table 3.3: Table 3.4: Current stand BA (ft2/ac): 15.8Current stand QMD (in): 10.6Current stand TPA: 18 Individual 2-4 trees 5-9 trees 10-15 trees 16-25 trees 17% 33% 21% 10% 19% Note: values are the percent of trees in each clump size 3.2.2 5. Obtain targets for clump proportions Step 5 in Churchill et al. (2016): ICO prescriptions are based on a target proportion of trees in different sized clumps within a stand. Proportions are just the percentage of trees, or TPA, that are in different sized clumps. Basal area proportions can be used, but we have found TPA targets to be more straightforward to use. Ideally, a table summarizing clump proportions for a range of reference conditions in your area is available (Table 2). If not, instructions for developing one are provided in section VI. (p.12) Section VI of Churchill et al. (2016) notes that reference spatial information may already be available and summarized in a way that it can be directly incorporated into ICO prescriptions. Such data exist and have been published for areas in Arizona (Abella and Denton 2009, Sánchez Meador et al. 2011), the eastern Washington Cascades (Churchill et al. 2013), the northern Rockies (Larson et al. 2012), and the Sierra Nevada (Lydersen et al. 2013). Reference datasets for using ICO in other forest types, such as coastal Douglas-fir or Pacific silver fir, also exist (Larson and Churchill 2008). (p.28) Table 2 is: 3.2.3 6. Select target clump proportions for your stand Now set the desired BA, QMD, and proportion of trees in each clump size: ######################################################################################## ######################################################################################## # desired BA, QMD, and proportion of trees in each clump size ######################################################################################## ######################################################################################## # desired BA target_ba = 10 # cannot be &gt; current BA # desired QMD target_qmd = 12 # desired proportion (%) of trees in each clump size # !cannot be create larger proportion of &quot;&gt;25 trees&quot; clump as this would require adding trees... # c(&quot;Individual&quot;, &quot;2-4 trees&quot;, &quot;5-9 trees&quot;, &quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) # c(.18, .33, .24, .10, .15) target_pcts = c(30, 40, 15, 10, 5, 0) ######################################################################################## ######################################################################################## # desired BA, QMD, and proportion of trees in each clump size ######################################################################################## ######################################################################################## Check set up and define data with targets based on Churchill et al. (2016) and their prescription worksheet Excel file to help develop ICO prescriptions get_target_check_prescription = function( clump_n_trees_grp_summary_dta , target_ba = as.numeric(NA) , target_qmd = as.numeric(NA) , target_pcts = as.numeric(NA) ){ if( is.na(target_ba) | is.na(target_qmd) | max(is.na(target_pcts))==1 ){ stop(&quot;must set all of the function parameters:\\n`target_ba`, `target_qmd`, and `target_pcts`&quot;) } ############################################# # check target BA and TPA ############################################# if(as.numeric(target_ba)&gt;clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1]){ stop( &quot;target BA in `target_ba` of &quot; , round(as.numeric(target_ba),1), &quot; is greater than current BA of &quot; , clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1] %&gt;% round(1) ) } if( get_tpa(target_ba, target_qmd)&gt;clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] ){ stop( &quot;target TPA in of &quot; , round(as.numeric(get_tpa(target_ba, target_qmd)),1), &quot; is greater than current TPA of &quot; , clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] %&gt;% round(1) , &quot;\\n adjust `target_ba` and/or `target_qmd` to get valid TPA&quot; ) } ############################################# # define data with current and target # ... this is &quot;smart&quot; in that percentages are adj based on: # ... 0) are there missing targets? # ... ... if &lt; 6 numbers provided in `target_pcts` then the largest tree groups get targets of 0 # ... 1) do targets sum to 1? # ... ... if not trees are distributed proportionally based on targets provided and trees available # ... 2) is target in largest clump size &gt; current conditions? # ... ... if yes, target is set to current condition # ... 3) is target listed in clump size &gt; current largest clump with trees? # ... ... if yes, target for largest clump size is shifted to current largest clump with trees ############################################# target_data = # create data for joining if missing clump groups dplyr::tibble( stand_area_ac = rep(clump_n_trees_grp_summary_dta$stand_area_ac[1],6) , clump_n_trees_grp = factor( c(1:6) , labels = c(&quot;Individual&quot;, &quot;2-4 trees&quot;, &quot;5-9 trees&quot;, &quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) , ordered = T ) , mean_clump_n_trees = c(1,3,7,12,20,30) , min_clump_n_trees = c(1,2,5,10,16,26) , max_clump_n_trees = c(1,4,9,15,25,99999) ) %&gt;% dplyr::left_join( clump_n_trees_grp_summary_dta %&gt;% dplyr::ungroup() %&gt;% dplyr::select(clump_n_trees_grp, pct_stand_n_trees, stand_n_clumps) ) %&gt;% dplyr::mutate( pct_stand_n_trees = dplyr::coalesce(pct_stand_n_trees,0) , stand_n_clumps = dplyr::coalesce(stand_n_clumps,0) ) %&gt;% # add targets dplyr::bind_cols( pct_stand_n_trees_target = c(as.numeric(target_pcts), rep(0,6))[1:6] # pad target with 0&#39;s ) %&gt;% # adjust target based on difference from 1 dplyr::mutate( pct_stand_n_trees_target = pct_stand_n_trees_target*(1/sum(pct_stand_n_trees_target)) # largest clump size with trees , largest_w_trees = max(ifelse(dplyr::coalesce(pct_stand_n_trees)&gt;0,clump_n_trees_grp,NA),na.rm = T) , largest_w_trees_target = max(ifelse(dplyr::coalesce(pct_stand_n_trees_target)&gt;0,clump_n_trees_grp,NA),na.rm = T) ) %&gt;% # move target for largest clump size to the largest current clump size dplyr::mutate( pct_stand_n_trees_target = dplyr::case_when( as.numeric(clump_n_trees_grp)==largest_w_trees &amp; largest_w_trees_target&gt;largest_w_trees ~ max( ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees_target,pct_stand_n_trees_target,0) ) , T ~ pct_stand_n_trees_target ) ) %&gt;% # adjust target based on current conditions dplyr::mutate( pct_stand_n_trees_target = dplyr::case_when( as.numeric(clump_n_trees_grp)&gt;largest_w_trees &amp; pct_stand_n_trees_target &gt; 0 ~ 0 , as.numeric(clump_n_trees_grp)==largest_w_trees &amp; pct_stand_n_trees_target &gt; pct_stand_n_trees ~ pct_stand_n_trees , T ~ pct_stand_n_trees_target ) ) %&gt;% # finally, re-scale again based on adjustments dplyr::mutate( pct_stand_n_trees_target = dplyr::case_when( as.numeric(clump_n_trees_grp)==largest_w_trees ~ pct_stand_n_trees_target , T ~ pct_stand_n_trees_target * ( # pct remaining to scale to (1-max(ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees,pct_stand_n_trees_target,0))) / # current pct remaining total allocated sum( ifelse(as.numeric(clump_n_trees_grp)!=largest_w_trees,pct_stand_n_trees_target,0)) ) ) ) %&gt;% # add other targets dplyr::rename(pct_stand_n_trees_current = pct_stand_n_trees) %&gt;% dplyr::mutate( stand_trees_per_ac_current = clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] , stand_trees_per_ac_target = dplyr::coalesce(get_tpa(target_ba, target_qmd),0) , trees_per_acre_current = stand_trees_per_ac_current*pct_stand_n_trees_current , trees_per_acre_target = stand_trees_per_ac_target*pct_stand_n_trees_target , clumps_per_acre_current = trees_per_acre_current/mean_clump_n_trees , clumps_per_acre_target = trees_per_acre_target/mean_clump_n_trees , stand_n_clumps_current = stand_n_clumps , stand_n_clumps_target = (clumps_per_acre_target*stand_area_ac) %&gt;% round(0) ) %&gt;% dplyr::select(-c(tidyselect::starts_with(&quot;largest_w_trees&quot;), stand_n_clumps)) # ???? # target_data %&gt;% glimpse() # issue warning about targets if(min(target_data$pct_stand_n_trees_target == c(as.numeric(target_pcts), rep(0,6))[1:6])==0){ warning( &quot;proportion of trees in each clump size target `target_pcts` adjusted!!!&quot; , &quot;\\nfrom : &quot;, paste(round(target_pcts,2),collapse = &quot;,&quot;) , &quot;\\nto : &quot;, paste(round(target_data$pct_stand_n_trees_target,2),collapse = &quot;,&quot;) ) } # return return(target_data) } # call it target_data_temp = get_target_check_prescription( clump_n_trees_grp_summary_temp , target_ba = target_ba , target_qmd = target_qmd , target_pcts = target_pcts ) ## Warning in get_target_check_prescription(clump_n_trees_grp_summary_temp, : proportion of trees in each clump size target `target_pcts` adjusted!!! ## from : 30,40,15,10,5,0 ## to : 0.3,0.4,0.15,0.1,0.05,0 # what? target_data_temp %&gt;% dplyr::glimpse() ## Rows: 6 ## Columns: 15 ## $ stand_area_ac &lt;dbl&gt; 22.21743, 22.21743, 22.21743, 22.21743, 22.… ## $ clump_n_trees_grp &lt;ord&gt; Individual, 2-4 trees, 5-9 trees, 10-15 tre… ## $ mean_clump_n_trees &lt;dbl&gt; 1, 3, 7, 12, 20, 30 ## $ min_clump_n_trees &lt;dbl&gt; 1, 2, 5, 10, 16, 26 ## $ max_clump_n_trees &lt;dbl&gt; 1, 4, 9, 15, 25, 99999 ## $ pct_stand_n_trees_current &lt;dbl&gt; 0.1670762, 0.3292383, 0.2113022, 0.1031941,… ## $ pct_stand_n_trees_target &lt;dbl&gt; 0.30, 0.40, 0.15, 0.10, 0.05, 0.00 ## $ stand_trees_per_ac_current &lt;dbl&gt; 18.33278, 18.33278, 18.33278, 18.33278, 18.… ## $ stand_trees_per_ac_target &lt;dbl&gt; 13, 13, 13, 13, 13, 13 ## $ trees_per_acre_current &lt;dbl&gt; 3.062971, 6.035854, 3.873757, 1.891835, 3.4… ## $ trees_per_acre_target &lt;dbl&gt; 3.90, 5.20, 1.95, 1.30, 0.65, 0.00 ## $ clumps_per_acre_current &lt;dbl&gt; 3.0629709, 2.0119515, 0.5533939, 0.1576529,… ## $ clumps_per_acre_target &lt;dbl&gt; 3.9000000, 1.7333333, 0.2785714, 0.1083333,… ## $ stand_n_clumps_current &lt;dbl&gt; 68, 51, 14, 3, 4, 0 ## $ stand_n_clumps_target &lt;dbl&gt; 87, 39, 6, 2, 1, 0 current vs target target_data_temp %&gt;% dplyr::select( clump_n_trees_grp , tidyselect::starts_with(&quot;pct_stand_n_trees&quot;) , tidyselect::starts_with(&quot;trees_per_acre_&quot;) ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;pct_stand_n_trees&quot;) , ~ scales::percent(.x,accuracy = 1) ) ) %&gt;% kableExtra::kable( caption = paste0( &quot;Current stand BA (ft2/ac): &quot; , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand QMD (in): &quot; , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand TPA: &quot; , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %&gt;% scales::number(accuracy = 1) ) , escape = F , digits = 1 , col.names = c( &quot;&quot;, rep(c(&quot;current&quot;,&quot;target&quot;),2) ) ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::add_header_above( c(&quot; &quot;=1,&quot;% Trees&quot;=2, &quot;TPA&quot;=2) ) Table 3.5: Table 3.6: Current stand BA (ft2/ac): 15.8Current stand QMD (in): 10.6Current stand TPA: 18 % Trees TPA current target current target Individual 17% 30% 3.1 3.9 2-4 trees 33% 40% 6.0 5.2 5-9 trees 21% 15% 3.9 2.0 10-15 trees 10% 10% 1.9 1.3 16-25 trees 19% 5% 3.5 0.7 &gt;25 trees 0% 0% 0.0 0.0 3.2.4 8. Combine clump and opening targets with leave tree criteria into marking guidelines Use our UAS tree list to generate the prescription: start with the largest clump size currently with trees cut trees to the next largest clump size until desired # clumps is reached repeat with each successive clump size through to individual tree selection if possible, cut in same clump until desired proportions are reached to minimize machine time 3.2.4.1 Function to cut clumps put the entire process outlined immediately above into a function to use with the tree list to cut each clump and then we’ll select the desired proportion of clumps 3.2.4.1.1 define intermediate functions define intermediate functions ############################################## # working with sf LINESTRINGS ############################################## # first two functions borrowed from https://github.com/metafor-ulaval/ALSroads/blob/main/R/line_tools.R ######## # Get heading of both ends of a line ######## st_ends_heading &lt;- function(line){ M &lt;- sf::st_coordinates(line) i &lt;- c(2, nrow(M) - 1) j &lt;- c(1, -1) headings &lt;- mapply(i, j, FUN = function(i, j) { Ax = M[i-j,1] Ay = M[i-j,2] Bx = M[i,1] By = M[i,2] atan2(Ay-By, Ax-Bx)*180/pi }) names(headings) &lt;- c(&quot;head&quot;, &quot;tail&quot;) return(headings) } ######## # extend the line on both ends ######## st_extend_line &lt;- function(line, distance, end = &quot;BOTH&quot;){ if (!(end %in% c(&quot;BOTH&quot;, &quot;HEAD&quot;, &quot;TAIL&quot;)) | length(end) != 1) stop(&quot;&#39;end&#39; must be &#39;BOTH&#39;, &#39;HEAD&#39; or &#39;TAIL&#39;&quot;) M &lt;- sf::st_coordinates(line)[,-3] keep &lt;- !(end == c(&quot;TAIL&quot;, &quot;HEAD&quot;)) ends &lt;- c(1, nrow(M))[keep] headings &lt;- st_ends_heading(line)[keep] / 180 * pi distances &lt;- if (length(distance) == 1) rep(distance, 2) else distance[1:2] M[ends, 1:2] &lt;- M[ends, 1:2] + distances[keep] * c(cos(headings), sin(headings)) newline &lt;- sf::st_linestring(M) # If input is sfc_LINESTRING and not sfg_LINESTRING if (is.list(line)) newline &lt;- sf::st_sfc(newline, crs = sf::st_crs(line)) return(newline) } ######## # pass an sf dataframe of points and return a line between the farthest points ######## st_points_to_line &lt;- function(pts, line_ext=0) { if(max(class(ttops_temp) %in% c(&quot;sf&quot;))!=1){ stop(&quot;must provide an object of class `sf`&quot;) } # find farthest distance between points dist_temp = sf::st_distance(pts) # get the points f_pts_temp = pts %&gt;% dplyr::ungroup() %&gt;% dplyr::slice( # get the farthest points from distance matrix which(dist_temp == max(dist_temp), arr.ind = TRUE)[1,] ) # draw a line between the farthest two points f_line_temp = f_pts_temp %&gt;% # convert to linestring dplyr::ungroup() %&gt;% dplyr::summarise(n=dplyr::n()) %&gt;% sf::st_cast(&quot;LINESTRING&quot;) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(-c(n)) # and apply the line extension farthest_line = st_extend_line(f_line_temp, distance = line_ext) # return return(farthest_line) } # st_points_to_line(ttops_temp %&gt;% dplyr::slice_head(prop = .1), line_ext = 6) %&gt;% # ggplot() + geom_sf() + geom_sf(data = ttops_temp %&gt;% dplyr::slice_head(prop = .1)) + theme_void() ######## # Function to calculate Euclidean distance between 2 points ######## st_euclidean_distance &lt;- function(p1,p2) { return(sqrt((p2[1] - p1[1])^2 + (p2[2] - p1[2])^2)) } ######## # return a line perpendicular to current line ######## ### https://stackoverflow.com/questions/56771058/perpendicular-lines-at-regular-intervals-along-lines-with-multiple-nodes # Function to calculate 2 points on a line perpendicular to another defined by 2 points p1,p2 # For point at interval, which can be a proportion of the segment length, or a constant st_perp_line &lt;- function(interval=0.5, my_line, proportion=TRUE) { # get end points of line p1 = my_line %&gt;% sf::st_cast(&quot;POINT&quot;) %&gt;% sf::st_coordinates() %&gt;% .[1,] p2 = my_line %&gt;% sf::st_cast(&quot;POINT&quot;) %&gt;% sf::st_coordinates() %&gt;% .[2,] # get length of line to return equal length line line_len = sf::st_length(my_line) %&gt;% as.numeric() %&gt;% `/`(2) # get crs of line my_crs = sf::st_crs(my_line) # Calculate x and y distances x_len &lt;- p2[1] - p1[1] y_len &lt;- p2[2] - p1[2] # If proportion calculate reference point from tot_length if (proportion) { point &lt;- c(p1[1]+x_len*interval,p1[2]+y_len*interval) } # Else use the constant value else { tot_len &lt;- st_euclidean_distance(p1,p2) point &lt;- c(p1[1]+x_len/tot_len*interval,p1[2]+y_len/tot_len*interval) } # Calculate the x and y distances from reference point to point on line line_len distance away ref_len &lt;- st_euclidean_distance(point,p2) xn_len &lt;- (line_len / ref_len) * (p2[1] - point[1]) yn_len &lt;- (line_len / ref_len) * (p2[2] - point[2]) # fix for identical if(identical(point,p2) &amp; x_len&gt;y_len){ # this works for horizontal line xn_len &lt;- line_len/2 yn_len &lt;- 0 }else if(identical(point,p2) &amp; x_len&lt;y_len){ # this works for vertical line xn_len &lt;- 0 yn_len &lt;- line_len/2 } # Invert the x and y lengths and add/subtract from the refrence point # ref_points &lt;- rbind(point,c(point[1] + yn_len,point[2] - xn_len),c(point[1] - yn_len,point[2] + xn_len)) ref_points &lt;- rbind(c(point[1] + yn_len,point[2] - xn_len),c(point[1] - yn_len,point[2] + xn_len)) # use the reference points to return a line return( ref_points %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename_with(tolower) %&gt;% sf::st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;), crs = my_crs, remove = F) %&gt;% dplyr::summarise(n=dplyr::n()) %&gt;% sf::st_cast(&quot;LINESTRING&quot;) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(-c(n)) ) } # st_perp_line( # my_line = st_points_to_line(ttops_temp %&gt;% dplyr::slice_head(prop = .1), line_ext = 6) # ) %&gt;% # ggplot() + # geom_sf(data = ttops_temp %&gt;% dplyr::slice_head(prop = .1)) + # points # geom_sf(color = &quot;blue&quot;) + # perp line # geom_sf( # farthest line # data = st_points_to_line(ttops_temp %&gt;% dplyr::slice_head(prop = .1), line_ext = 6) # , color = &quot;black&quot; # ) + # theme_void() 3.2.4.1.2 function to pass a clump generate data using clumping functions above, pass that data, return tree list with cut/keep flag based on the target clump group size # function to cut a single clump cut_clump_fn &lt;- function( c # clump id from need_cut_trees data , need_cut_trees # data with clumps already defined returned by st_clump_points() , tgt = tgt # select one level of input passed to st_clump_points() ... # ... clump_labels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) ){ # use only the current clump curr_dta = need_cut_trees %&gt;% dplyr::filter(clump_id == c) if(nrow(curr_dta)&lt;1){ stop(&quot;cannot find data with the clump_id == `c` in `need_cut_trees` data&quot;) } # get distance used to create clumps in st_clump_points() dist_temp = curr_dta$tree_clump_dist_m[1] # do we even need to cut? reclump = st_clump_points(x = curr_dta, clump_dist_m = dist_temp) if( ( reclump %&gt;% dplyr::pull(clump_id) %&gt;% unique() %&gt;% length() ) != 1 ){ stop(&quot;this is not a clump...send the `need_cut_trees` data through the st_clump_points function again&quot;) } # do we even need to cut? if( unique(reclump$clump_n_trees_grp) == tgt ){ return( reclump %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, is_keep_tree) ) } # create clump polygon clumps = get_clump_summary(curr_dta) # get the farthest line between points f_line_temp = st_points_to_line(curr_dta, line_ext = dist_temp) # get perpendicular lines in dataset which we can iterate over to make cuts perp_line_sf_temp = # for every 1 m along line length, get a new perp line seq( from = 0 , to = sf::st_length(f_line_temp) %&gt;% as.numeric() %&gt;% floor() , by = 1 ) %&gt;% purrr::map( st_perp_line , my_line = f_line_temp , proportion = F ) %&gt;% dplyr::bind_rows() %&gt;% dplyr::mutate(line_n = dplyr::row_number()) # find intersection of lines with the polygon and add length of intersection to perp line data perp_line_sf_temp = perp_line_sf_temp %&gt;% dplyr::inner_join( # intersect and calc len perp_line_sf_temp %&gt;% sf::st_intersection( clumps %&gt;% dplyr::ungroup() %&gt;% dplyr::select(clump_id) %&gt;% dplyr::filter(clump_id == c) ) %&gt;% dplyr::mutate(len_m = sf::st_length(geometry) %&gt;% as.numeric()) %&gt;% sf::st_drop_geometry() , by = &quot;line_n&quot; ) # make cuts at the points where there is the least overlap with the clump polygon # list of potential line cut + tree combinations # aggregate the mean length of the intersecting cut lines to the tree level # prioritize trees for removal that have smallest length cut_tree_lines_temp = curr_dta %&gt;% sf::st_buffer(dist_temp/2) %&gt;% sf::st_join(perp_line_sf_temp) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(treeID) %&gt;% dplyr::summarise(len_m = mean(len_m, na.rm = T)) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(len_m, treeID) %&gt;% dplyr::mutate(n = dplyr::row_number()) ############################################################### # while ############################################################### # cut until the desired clump size is achieved based on these cut lines while_temp = 1 i = 1 while(while_temp==1) { # cut trees cut_trees_temp = cut_tree_lines_temp %&gt;% dplyr::slice(1:i) %&gt;% dplyr::distinct(treeID) # get the remaining trees not cut trees_remain_temp = curr_dta %&gt;% dplyr::anti_join(cut_trees_temp, by = &quot;treeID&quot;) # ensure that there are trees if(nrow(trees_remain_temp)==0){ if(best_desired_grps_n_temp==0){ # there are no more possible cuts :/ # ... so we&#39;re going to add trees until the desired clump size is reached # start with biggest tree and keep adding trees until the desired clump size is reached start_tree = curr_dta %&gt;% dplyr::arrange(desc(dbh_cm)) %&gt;% dplyr::filter(dplyr::row_number() == 1) increment_m = 0.5 k = 1 keep_trees = dplyr::tibble(treeID = character(0)) while(nrow(keep_trees)==0){ # create a polygon to intersect with tree points and keep trees until number of trees met poly_keep = start_tree %&gt;% sf::st_buffer( (dist_temp/2) + increment_m*k ) %&gt;% dplyr::mutate(dummy = 1) %&gt;% dplyr::select(dummy) # intersect and clump i_trees = curr_dta %&gt;% sf::st_intersection(poly_keep) %&gt;% st_clump_points(clump_dist_m = dist_temp) i_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(clump_n_trees_grp, clump_id) # keep only the desired clump keep_trees = i_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter( clump_id == i_trees %&gt;% dplyr::filter(clump_n_trees_grp == tgt) %&gt;% dplyr::pull(clump_id) %&gt;% .[1] %&gt;% dplyr::coalesce(&quot;nope&quot;) ) %&gt;% dplyr::select(treeID) # increment k = k+1 } # the remaining trees are cuts best_cuts = curr_dta %&gt;% sf::st_drop_geometry() %&gt;% dplyr::anti_join(keep_trees, by = &quot;treeID&quot;) %&gt;% dplyr::select(treeID) }else if( best_desired_grps_n_temp&gt;0 ){ ############################### # add trees back in until gets worse ############################### j = 1 while_add = 1 while(while_add==1){ # cut trees cut_trees_temp = best_cuts %&gt;% # add trees back in (i.e. remove them from the cut trees) dplyr::anti_join( cut_tree_lines_temp %&gt;% dplyr::slice(1:j) %&gt;% dplyr::distinct(treeID) , by = &quot;treeID&quot; ) # get the remaining trees not cut trees_remain_temp = curr_dta %&gt;% dplyr::anti_join(cut_trees_temp, by = &quot;treeID&quot;) # count the groups remaining after cuts desired_grps_n_temp = trees_remain_temp %&gt;% st_clump_points(clump_dist_m = dist_temp) %&gt;% sf::st_drop_geometry() %&gt;% # do we have group sizes we want? dplyr::filter(clump_n_trees_grp == tgt) %&gt;% nrow() if(desired_grps_n_temp&gt;=best_desired_grps_n_temp){ # is this better than the best best_cuts = cut_trees_temp best_desired_grps_n_temp = desired_grps_n_temp }else{ # stop it while_add = 0 } # increment j = j + 1 } # while(while_add==1) } # best_desired_grps_n_temp&gt;0 # done so stop the whole stop it while_temp = 0 }else{ # if(nrow(trees_remain_temp)==0) # count the groups remaining after cuts desired_grps_n_temp = trees_remain_temp %&gt;% st_clump_points(clump_dist_m = dist_temp) %&gt;% sf::st_drop_geometry() %&gt;% # do we have group sizes we want? dplyr::filter(clump_n_trees_grp == tgt) %&gt;% nrow() ### store best cut list if(i==1){ best_cuts = cut_trees_temp best_desired_grps_n_temp = desired_grps_n_temp }else if(desired_grps_n_temp&gt;best_desired_grps_n_temp){ # is this better than the best best_cuts = cut_trees_temp best_desired_grps_n_temp = desired_grps_n_temp }else if( desired_grps_n_temp==best_desired_grps_n_temp &amp; i!=nrow(cut_tree_lines_temp) ){ best_cuts = best_cuts best_desired_grps_n_temp = best_desired_grps_n_temp }else if( best_desired_grps_n_temp&gt;0 &amp; desired_grps_n_temp&lt;best_desired_grps_n_temp ){ # is this worse than the best which was successful? ############################### # add trees back in until gets worse ############################### j = 1 while_add = 1 while(while_add==1){ # cut trees cut_trees_temp = best_cuts %&gt;% # add trees back in (i.e. remove them from the cut trees) dplyr::anti_join( cut_tree_lines_temp %&gt;% dplyr::slice(1:j) %&gt;% dplyr::distinct(treeID) , by = &quot;treeID&quot; ) # get the remaining trees not cut trees_remain_temp = curr_dta %&gt;% dplyr::anti_join(cut_trees_temp, by = &quot;treeID&quot;) # count the groups remaining after cuts desired_grps_n_temp = trees_remain_temp %&gt;% st_clump_points(clump_dist_m = dist_temp) %&gt;% sf::st_drop_geometry() %&gt;% # do we have group sizes we want? dplyr::filter(clump_n_trees_grp == tgt) %&gt;% nrow() if(desired_grps_n_temp&gt;=best_desired_grps_n_temp){ # is this better than the best best_cuts = cut_trees_temp best_desired_grps_n_temp = desired_grps_n_temp }else{ # stop it while_add = 0 } # increment j = j + 1 } # while(while_add==1) # done so stop the whole stop it while_temp = 0 }else if( i==nrow(cut_tree_lines_temp) ){ # is this the end? # stop it while_temp = 0 } ### increment i = i+1 } # else if(nrow(trees_remain_temp)==0) } # while(while_temp==1) # return it # return treelist with cut/keep # join to original data and pull d_temp = curr_dta %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate(is_keep_tree = as.numeric(NA)) %&gt;% dplyr::select(-c(is_keep_tree)) %&gt;% dplyr::left_join( best_cuts %&gt;% dplyr::mutate(is_keep_tree = 0) , by = dplyr::join_by(&quot;treeID&quot;) ) %&gt;% dplyr::mutate(is_keep_tree = dplyr::coalesce(is_keep_tree, 1)) %&gt;% dplyr::select(treeID, is_keep_tree) # returns treeID and keep tree flag data frame return(d_temp) } # # example # # pass it a clump id in the data # ttops_temp %&gt;% # dplyr::filter(clump_n_trees_grp == &quot;2-4 trees&quot;) %&gt;% # dplyr::arrange(desc(clump_n_trees)) %&gt;% # dplyr::slice(1) %&gt;% # dplyr::pull(clump_id) %&gt;% # cut_clump_fn( # need_cut_trees = ttops_temp # , tgt = &quot;Individual&quot; # ) there are some cases where the cut_clumps_fn may not return the desired tree clumps based on a single pass using the initial cut lines…iterate over the function until all clumps are in the desired clump size or smaller. get_cut_clump &lt;- function( c # clump id from need_cut_trees data , need_cut_trees # data with clumps already defined returned by st_clump_points() , tgt = tgt # select one level of input passed to st_clump_points() ... # ... clump_labels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) ) { # what if we need to keep cutting because could not find a solution based on initial cut lines? cuts_first = cut_clump_fn( c = c , need_cut_trees = need_cut_trees , tgt = tgt ) # did we get the target? new_clumps = need_cut_trees %&gt;% dplyr::inner_join( cuts_first %&gt;% dplyr::filter(is_keep_tree == 1) %&gt;% dplyr::select(treeID) , by = &quot;treeID&quot; ) %&gt;% st_clump_points() # new_clumps %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(clump_n_trees_grp) while( ( new_clumps %&gt;% dplyr::filter(clump_n_trees_grp &gt; tgt) %&gt;% nrow() ) &gt; 0 ){ # redo the cut clump # redo the cut clump cuts_again = new_clumps %&gt;% dplyr::filter(clump_n_trees_grp &gt; tgt) %&gt;% dplyr::pull(clump_id) %&gt;% unique() %&gt;% purrr::map(cut_clump_fn, need_cut_trees = new_clumps, tgt = tgt) %&gt;% dplyr::bind_rows() %&gt;% dplyr::rename(updt = is_keep_tree) # update the original cut data cuts_first = cuts_first %&gt;% dplyr::left_join( cuts_again , by = &quot;treeID&quot; ) %&gt;% dplyr::mutate(is_keep_tree = dplyr::coalesce(updt, is_keep_tree)) %&gt;% dplyr::select(-c(updt)) # reset the new clumps new_clumps = need_cut_trees %&gt;% dplyr::inner_join( cuts_first %&gt;% dplyr::filter(is_keep_tree == 1) %&gt;% dplyr::select(treeID) , by = &quot;treeID&quot; ) %&gt;% st_clump_points() # new_clumps %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(clump_n_trees_grp) } # end while return(cuts_first) } 3.2.4.1.3 function to pass a tree list function to pass a whole tree list of sf point data ############################################## # get cut keep tree flag ############################################## get_keep_tree_flag &lt;- function( x # x = sf point data , tgt # tgt = clump_n_trees_grp level defined in st_clump_points: ... ## ... clump_labels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;16-25 trees&quot;,&quot;&gt;25 trees&quot;) , clump_dist_m = 6 # size (radius) of the epsilon neighborhood = maximum distance between points to add to clump ) { # MAKE CUTS INDEPENDENT OF CURRENT CLUMP GROUPING... # what if we pass a tree list with trees already cut? and thus, potentially different clump group sizes than is # currently defined in clump_n_trees_grp? # 1) apply the clump grouping # 2) only go through the cut alg for clumps that need cutting to the target # 3) append the trees in target clump or lower to the list at the end ############################# # 1) apply the clump grouping ############################# new_clump_trees = x %&gt;% st_clump_points(clump_dist_m = clump_dist_m) # need cutting still need_cut_trees = new_clump_trees %&gt;% dplyr::filter(clump_n_trees_grp &gt; tgt) ############################# # 2) only go through the cut alg for clumps that need cutting to the target ############################# # for each clump that still needs cutting, iterate over and return keep/cut flag compl_need_cut_trees = need_cut_trees %&gt;% dplyr::pull(clump_id) %&gt;% unique() %&gt;% purrr::map(get_cut_clump, need_cut_trees = need_cut_trees, tgt = tgt) %&gt;% # purrr:map fn dplyr::bind_rows() ############################# # 4) append the trees in target clump or lower to the list at the end ############################# compl_need_cut_trees = compl_need_cut_trees %&gt;% dplyr::bind_rows( new_clump_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(clump_n_trees_grp &lt;= tgt) %&gt;% dplyr::mutate(is_keep_tree = 1) %&gt;% dplyr::select(treeID, is_keep_tree) ) # return return( # original data so that order is preserved x %&gt;% # add on trees that got cut with trees already good dplyr::inner_join( compl_need_cut_trees , by = &quot;treeID&quot; ) %&gt;% dplyr::pull(is_keep_tree) ) } # get_keep_tree_flag 3.2.4.2 Process to cut groups incrementally cut groups incrementally to achieve target tree clump group size proportions # must first have target data # target_data_temp = get_target_check_prescription( # clump_n_trees_grp_summary_temp # , target_ba = target_ba # , target_qmd = target_qmd # , target_pcts = target_pcts # ) # what is the smallest group with a target? sm_grp_temp = target_data_temp %&gt;% dplyr::filter(pct_stand_n_trees_target&gt;0) %&gt;% dplyr::pull(clump_n_trees_grp) %&gt;% min() # start with the largest group in target data currently with trees grp_temp = target_data_temp %&gt;% dplyr::arrange(desc(clump_n_trees_grp)) %&gt;% dplyr::filter(pct_stand_n_trees_current&gt;0) %&gt;% dplyr::slice(1) %&gt;% dplyr::pull(clump_n_trees_grp) message( paste(&quot;started cutting&quot;, grp_temp, &quot;at&quot;, Sys.time()) ) # identify clumps to leave untouched # clump_polys_temp = get_clump_summary(ttops_temp) keep_clumps_temp = clump_polys_temp %&gt;% sf::st_drop_geometry() %&gt;% #keep only trees in current group dplyr::inner_join( target_data_temp %&gt;% dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% dplyr::select( clump_n_trees_grp, mean_clump_n_trees, min_clump_n_trees, max_clump_n_trees , stand_n_clumps_target ) , by = &quot;clump_n_trees_grp&quot; ) %&gt;% # keep only clumps that meet criteria dplyr::filter( n_trees &gt;= min_clump_n_trees &amp; n_trees &lt;= max_clump_n_trees ) %&gt;% # keep clumps closest the mean number in target dplyr::mutate( pct_to_target = abs( (n_trees-mean_clump_n_trees)/mean_clump_n_trees ) ) %&gt;% dplyr::arrange(pct_to_target, desc(qmd_cm), n_trees, clump_id) %&gt;% dplyr::filter(dplyr::row_number()&lt;=stand_n_clumps_target) %&gt;% dplyr::select(clump_id) # !!!!!!!!!!FIX: WHAT IF WE HAVE CLUMPS OF THIS SIZE BUT THE N_TREES&gt;MAX_TREES AND NEED TO GET CLUMPS OF THIS SIZE? # ... UPDATE CUTTING ALG TO CUT CLUMP DOWN TO MIN-MAX TREE RANGE FOR CLUMPS WITH INF UPPER LIMIT # start building tree list with keep/cut flag # ttops_temp = get_tree_clumps( # my_suid = my_suid # , tree_clump_dist_m = tree_clump_dist_m # , ostory_dbh_cm = ostory_dbh_cm # ) # build tree list keep_trees = ttops_temp %&gt;% dplyr::ungroup() %&gt;% sf::st_drop_geometry() %&gt;% dplyr::inner_join(keep_clumps_temp, by = &quot;clump_id&quot;) %&gt;% dplyr::select(treeID) %&gt;% dplyr::mutate(is_keep_tree = 1) # did we keep all of the clumps? if( nrow(keep_clumps_temp) == ( clump_polys_temp %&gt;% dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% nrow() ) ){ remaining_trees = dplyr::tibble( treeID = character(0) , is_keep_tree = numeric(0) ) }else{ # determine keep/cut for the remaining trees in that group type remaining_trees = ttops_temp %&gt;% dplyr::ungroup() %&gt;% # keep only trees in current grp dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% # remove keep trees dplyr::anti_join(keep_trees, by = &quot;treeID&quot;) # apply the cutting algorithm # get the flag remaining_trees$is_keep_tree = get_keep_tree_flag( x = remaining_trees , tgt = target_data_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(clump_n_trees_grp) %&gt;% dplyr::mutate(l = dplyr::lag(clump_n_trees_grp)) %&gt;% dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% dplyr::pull(l) , clump_dist_m = tree_clump_dist_m ) # select relevant columns remaining_trees = remaining_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::ungroup() %&gt;% dplyr::select(treeID, is_keep_tree) } message( paste(&quot;done cutting&quot;, grp_temp, &quot;at&quot;, Sys.time()) ) ############################################### # now process to go on to the next groups ############################################### # get the next group grp_temp = target_data_temp %&gt;% dplyr::filter(clump_n_trees_grp&lt;grp_temp) %&gt;% dplyr::arrange(desc(clump_n_trees_grp)) %&gt;% dplyr::slice(1) %&gt;% dplyr::pull(clump_n_trees_grp) while(grp_temp&gt;=sm_grp_temp &amp; grp_temp != &quot;Individual&quot;){ message( paste(&quot;started cutting&quot;, grp_temp, &quot;at&quot;, Sys.time()) ) # identify clumps to leave untouched # clump_polys_temp = get_clump_summary(ttops_temp) keep_clumps_temp = clump_polys_temp %&gt;% sf::st_drop_geometry() %&gt;% #keep only trees in current group dplyr::inner_join( target_data_temp %&gt;% dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% dplyr::select( clump_n_trees_grp, mean_clump_n_trees, min_clump_n_trees, max_clump_n_trees , stand_n_clumps_target ) , by = &quot;clump_n_trees_grp&quot; ) %&gt;% # keep only clumps that meet criteria dplyr::filter( n_trees &gt;= min_clump_n_trees &amp; n_trees &lt;= max_clump_n_trees ) %&gt;% # keep clumps closest the mean number in target group dplyr::mutate( pct_to_target = abs( (n_trees-mean_clump_n_trees)/mean_clump_n_trees ) ) %&gt;% dplyr::arrange(pct_to_target, desc(qmd_cm), n_trees, clump_id) %&gt;% dplyr::filter(dplyr::row_number()&lt;=stand_n_clumps_target) %&gt;% dplyr::select(clump_id) # add to tree list with keep/cut flag keep_trees = keep_trees %&gt;% dplyr::bind_rows( ttops_temp %&gt;% dplyr::ungroup() %&gt;% sf::st_drop_geometry() %&gt;% dplyr::inner_join(keep_clumps_temp, by = &quot;clump_id&quot;) %&gt;% dplyr::select(treeID) %&gt;% dplyr::mutate(is_keep_tree = 1) ) # check if the desired clump number was met and add the remaining trees from previous group if needed more_clumps_target = 0 if( nrow(keep_clumps_temp) &lt; ( target_data_temp %&gt;% dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% dplyr::pull(stand_n_clumps_target) ) ){ # how many more clumps are needed? more_clumps_target = ( target_data_temp %&gt;% dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% dplyr::pull(stand_n_clumps_target) ) - nrow(keep_clumps_temp) # determine group size of remaining trees in the group prior that were not in a group selected and were not cut potential_trees = ttops_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::inner_join( remaining_trees %&gt;% dplyr::filter(is_keep_tree == 1) %&gt;% dplyr::select(treeID) , by = &quot;treeID&quot; ) %&gt;% st_clump_points(clump_dist_m = tree_clump_dist_m) %&gt;% # ggplot() + geom_sf(aes(fill = clump_n_trees_grp)) + theme_void() # get the original clump id to prioritize new clump groups in the same area dplyr::inner_join( ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::ungroup() %&gt;% dplyr::select(treeID, clump_id) %&gt;% dplyr::rename(orig_clump_id = clump_id) , by = &quot;treeID&quot; ) %&gt;% dplyr::group_by(orig_clump_id) %&gt;% dplyr::mutate( pct_desired_grp = sum(ifelse(clump_n_trees_grp == grp_temp, 1, 0)) / dplyr::n() ) %&gt;% dplyr::ungroup() %&gt;% # keep only the current group dplyr::filter(clump_n_trees_grp == grp_temp) # pick trees from potential trees based on clump summary keep_trees = keep_trees %&gt;% dplyr::bind_rows( potential_trees %&gt;% sf::st_drop_geometry() %&gt;% # filter trees based on clumps needed dplyr::inner_join( get_clump_summary(potential_trees) %&gt;% sf::st_drop_geometry() %&gt;% # join with original clump id metrics to prioritize # keeping clumps in the same area and minimize cutting time dplyr::left_join( potential_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(clump_id, orig_clump_id) %&gt;% dplyr::summarise(pct_desired_grp = max(pct_desired_grp)) , by = &quot;clump_id&quot; ) %&gt;% # keep the number of clumps needed dplyr::arrange(desc(pct_desired_grp), orig_clump_id, desc(qmd_cm), n_trees, clump_id) %&gt;% dplyr::filter(dplyr::row_number()&lt;=more_clumps_target) %&gt;% dplyr::select(clump_id) , by = &quot;clump_id&quot; ) %&gt;% dplyr::select(treeID) %&gt;% dplyr::mutate(is_keep_tree = 1) ) } # end if don&#39;t have enough clumps #################################################### # determine keep/cut for the remaining trees in that group type and higher groups #################################################### remaining_trees = ttops_temp %&gt;% dplyr::ungroup() %&gt;% # REMOVE TREES FROM PREVIOUS TREES REMAINING that got cut to make this group size dplyr::anti_join( remaining_trees %&gt;% dplyr::filter(is_keep_tree == 0) , by = &quot;treeID&quot; ) %&gt;% # keep only trees in current grp or prior grp dplyr::filter(clump_n_trees_grp &gt;= grp_temp) %&gt;% # remove keep trees dplyr::anti_join(keep_trees, by = &quot;treeID&quot;) if(nrow(remaining_trees) &gt; 0){ # apply the cutting algorithm # get the flag remaining_trees$is_keep_tree = get_keep_tree_flag( x = remaining_trees , tgt = target_data_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(clump_n_trees_grp) %&gt;% dplyr::mutate(l = dplyr::lag(clump_n_trees_grp)) %&gt;% dplyr::filter(clump_n_trees_grp == grp_temp) %&gt;% dplyr::pull(l) , clump_dist_m = tree_clump_dist_m ) # select relevant columns remaining_trees = remaining_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::ungroup() %&gt;% dplyr::select(treeID, is_keep_tree) } # increment message( paste(&quot;done cutting&quot;, grp_temp, &quot;at&quot;, Sys.time()) ) # get the next group grp_temp = target_data_temp %&gt;% dplyr::filter(clump_n_trees_grp&lt;grp_temp) %&gt;% dplyr::arrange(desc(clump_n_trees_grp)) %&gt;% dplyr::slice(1) %&gt;% dplyr::pull(clump_n_trees_grp) %&gt;% dplyr::coalesce(&quot;Individual&quot;) } # now individuals if(sm_grp_temp == &quot;Individual&quot;){ message( paste(&quot;started cutting&quot;, sm_grp_temp, &quot;at&quot;, Sys.time()) ) potential_trees = # original data ttops_temp %&gt;% dplyr::filter(clump_n_trees_grp == &quot;Individual&quot;) %&gt;% # remaining trees dplyr::bind_rows( ttops_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::inner_join( remaining_trees %&gt;% dplyr::filter(is_keep_tree == 1) %&gt;% dplyr::select(treeID) , by = &quot;treeID&quot; ) ) %&gt;% # make sure that these are all individuals dplyr::mutate(is_orig = ifelse(clump_n_trees_grp==&quot;Individual&quot;, 1, 0)) %&gt;% st_clump_points(clump_dist_m = tree_clump_dist_m) %&gt;% dplyr::filter(clump_n_trees_grp == &quot;Individual&quot;) # pick trees from potential trees based on target keep_trees = keep_trees %&gt;% dplyr::select(treeID) %&gt;% dplyr::bind_rows( potential_trees %&gt;% sf::st_drop_geometry() %&gt;% # keep the number of clumps needed dplyr::arrange(desc(is_orig), desc(dbh_cm), desc(tree_height_m)) %&gt;% dplyr::filter( dplyr::row_number() &lt;= target_data_temp %&gt;% dplyr::filter(clump_n_trees_grp == &quot;Individual&quot;) %&gt;% dplyr::pull(stand_n_clumps_target) ) %&gt;% dplyr::select(treeID) ) %&gt;% dplyr::mutate(is_keep_tree = 1) message( paste(&quot;done cutting&quot;, sm_grp_temp, &quot;at&quot;, Sys.time()) ) } # get the final prescription prescription_trees = ttops_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::left_join( keep_trees , by = &quot;treeID&quot; ) %&gt;% # tracking vars dplyr::mutate( # fill in keep tree flag is_keep_tree = dplyr::coalesce(is_keep_tree, 0) , orig_clump_n_trees_grp = clump_n_trees_grp ) %&gt;% dplyr::select(-c(clump_n_trees_grp)) # attach the new clumping to the trees prescription_trees = prescription_trees %&gt;% dplyr::left_join( # reclump prescription_trees %&gt;% dplyr::filter(is_keep_tree == 1) %&gt;% st_clump_points(clump_dist_m = tree_clump_dist_m) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, clump_n_trees_grp) %&gt;% dplyr::rename(new_clump_n_trees_grp = clump_n_trees_grp) , by = &quot;treeID&quot; ) %&gt;% dplyr::mutate( new_clump_n_trees_grp = forcats::fct_na_value_to_level(new_clump_n_trees_grp, level = &quot;Cut tree&quot;) ) check the distribution of current vs prescription tree clump sizes prescription_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count( orig_clump_n_trees_grp, new_clump_n_trees_grp ) %&gt;% tidyr::pivot_wider(names_from = orig_clump_n_trees_grp, values_from = n, values_fill = 0) %&gt;% dplyr::arrange(new_clump_n_trees_grp) %&gt;% dplyr::rename(`New` = new_clump_n_trees_grp) %&gt;% kableExtra::kbl() %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::add_header_above( c(&quot; &quot;=1,&quot;Old&quot;=5) ) Old New Individual 2-4 trees 5-9 trees 10-15 trees 16-25 trees Individual 68 4 4 0 11 2-4 trees 0 102 0 0 0 5-9 trees 0 0 41 0 0 10-15 trees 0 0 0 27 0 16-25 trees 0 0 0 0 20 Cut tree 0 28 41 15 46 plot the prescription plot the distance raster and openings vector data we just got with overlaid tree clumps and tree points ttops_temp2 = prescription_trees %&gt;% dplyr::filter(is_keep_tree == 1) %&gt;% dplyr::select(treeID, dbh_cm, tree_height_m, basal_area_m2) %&gt;% st_clump_points(clump_dist_m = tree_clump_dist_m) clump_polys_temp2 = get_clump_summary(ttops_temp2) dist_rast_temp2 = get_clump_dist_rast(clump_polys_temp2) plt_fnl_temp2 = ggplot() + # distance geom_tile( data = dist_rast_temp2$dist_rast %&gt;% terra::aggregate(2, cores = 4) %&gt;% as.data.frame(xy = T) %&gt;% rename(f=3) , mapping = aes(x=x, y=y, fill = f) ) + harrypotter::scale_fill_hp( &quot;mischief&quot; , na.value = &quot;transparent&quot; , name = &quot;distance to\\nnearest tree (m)&quot; , limits = c(0,45) ) + # openings geom_sf(data = dist_rast_temp2$openings_vect, mapping = aes(color = openining_area_m2), fill = NA) + scale_color_gradient( low = &quot;gray77&quot;, high = &quot;gray11&quot; , labels = scales::comma_format(accuracy = 1) , name = latex2exp::TeX(&quot;opening\\narea ($\\\\m^2$)&quot;) , limits = c(0,70000) ) + # clumps ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp2 , mapping = aes(fill = clump_n_trees_grp) , color = NA ) + harrypotter::scale_fill_hp_d(&quot;always&quot;, name = &quot;clump size&quot;, drop = F) + # tree points geom_sf(data = ttops_temp2, color = &quot;gray88&quot;, shape = &quot;.&quot;) + theme_void() + theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) # plot plt_fnl_temp2 # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_11.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 7, device = &quot;jpeg&quot;) highlight the openings plt_open_temp2 = ggplot() + # clumps geom_sf( data = clump_polys_temp2 , mapping = aes(fill = clump_n_trees_grp) , color = NA ) + harrypotter::scale_fill_hp_d(&quot;always&quot;, name = &quot;clump size&quot;, drop = F) + # openings ggnewscale::new_scale_fill() + geom_sf(data = dist_rast_temp2$openings_vect, mapping = aes(fill = openining_area_m2), color = NA) + scale_fill_gradient( low = &quot;gray77&quot;, high = &quot;gray11&quot; , labels = scales::comma_format(accuracy = 1) , name = latex2exp::TeX(&quot;opening\\narea ($\\\\m^2$)&quot;) , limits = c(0,70000) ) + # tree points geom_sf(data = ttops_temp2, color = &quot;gray88&quot;, shape = &quot;.&quot;) + theme_void() + theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) plt_open_temp2 # save it combine plots with prescription plt_fnl_temp2 + (plt_open_temp2 + theme(legend.position = &quot;none&quot;)) &amp; theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) combine old vs new (plt_fnl_temp + labs(subtitle = &quot;Pre-Treatment&quot;)) + (plt_fnl_temp2 + labs(subtitle = &quot;Post-Treatment&quot;) + theme(legend.position = &quot;none&quot;)) &amp; theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_12.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 9, device = &quot;jpeg&quot;) combine old vs new openings highlight (plt_open_temp + labs(subtitle = &quot;Pre-Treatment&quot;)) + (plt_open_temp2 + labs(subtitle = &quot;Post-Treatment&quot;) + theme(legend.position = &quot;none&quot;)) &amp; theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) individual tree crowns pre- and post-treatment plt_crowns2 &lt;- ortho_plt_fn(stand = stand_sf) + # treetops ggnewscale::new_scale_fill() + geom_sf( data = crowns_sf_with_dbh %&gt;% dplyr::inner_join( treetops_sf_with_dbh %&gt;% sf::st_intersection(stand_sf) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID) ) %&gt;% dplyr::left_join( ttops_temp2 %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID) %&gt;% dplyr::mutate(is_keep = 1) ) , mapping = aes(fill = ifelse(is_keep==1, tree_height_ft, NA)) , color = &quot;gray55&quot; , lwd = 0.3 ) + harrypotter::scale_fill_hp(&quot;gryffindor&quot;, alpha = 0.8, limits = c(4,85), na.value = &quot;white&quot;) + labs(fill = &quot;Individual Tree\\nHt. (ft)&quot;) # combine (plt_crowns1 + labs(subtitle = &quot;Pre-Treatment&quot;) + theme(legend.position = &quot;right&quot;, legend.direction = &quot;vertical&quot;) ) + (plt_crowns2 + labs(subtitle = &quot;Post-Treatment&quot;) + theme(legend.position = &quot;none&quot;)) &amp; theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;), legend.title=element_text(size=8), legend.text=element_text(size = 7)) # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/saf_13.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 9, device = &quot;jpeg&quot;) table comparison current vs target vs prescription clump_n_trees_grp_summary_temp2 = get_clump_n_trees_grp_summary( trees = ttops_temp2, clumps = clump_polys_temp2 ) clump_n_trees_grp_summary_temp2 %&gt;% dplyr::glimpse() ## Rows: 5 ## Columns: 31 ## $ stand_area_ha &lt;dbl&gt; 8.991271, 8.991271, 8.991271, 8.991271, 8.… ## $ clump_n_trees_grp &lt;ord&gt; Individual, 2-4 trees, 5-9 trees, 10-15 tr… ## $ n_trees &lt;int&gt; 87, 102, 41, 27, 20 ## $ mean_dbh_cm &lt;dbl&gt; 28.51285, 28.99203, 24.24489, 21.35637, 32… ## $ mean_tree_height_m &lt;dbl&gt; 14.83899, 15.07171, 13.11534, 12.00485, 16… ## $ loreys_height_m &lt;dbl&gt; 17.17495, 16.61935, 14.54576, 12.28621, 17… ## $ basal_area_m2 &lt;dbl&gt; 8.821625, 9.794252, 2.680370, 1.468068, 2.… ## $ clump_area_ha &lt;dbl&gt; 0.24587432, 0.23157533, 0.07659498, 0.0457… ## $ stand_n_clumps &lt;int&gt; 87, 39, 6, 2, 1 ## $ trees_per_ha &lt;dbl&gt; 9.676052, 11.344337, 4.559978, 3.002913, 2… ## $ basal_area_m2_per_ha &lt;dbl&gt; 0.9811322, 1.0893068, 0.2981081, 0.1632771… ## $ qmd_cm &lt;dbl&gt; 29.94624, 29.87277, 25.28367, 21.53154, 33… ## $ stand_trees_per_ha &lt;dbl&gt; 30.80766, 30.80766, 30.80766, 30.80766, 30… ## $ stand_basal_area_m2 &lt;dbl&gt; 25.21768, 25.21768, 25.21768, 25.21768, 25… ## $ stand_basal_area_m2_per_ha &lt;dbl&gt; 2.804684, 2.804684, 2.804684, 2.804684, 2.… ## $ pct_stand_basal_area &lt;dbl&gt; 0.34981911, 0.38838835, 0.10628934, 0.0582… ## $ pct_stand_n_trees &lt;dbl&gt; 0.31407942, 0.36823105, 0.14801444, 0.0974… ## $ stand_qmd_cm &lt;dbl&gt; 28.81635, 28.81635, 28.81635, 28.81635, 28… ## $ mean_dbh_in &lt;dbl&gt; 11.234063, 11.422861, 9.552486, 8.414412, … ## $ qmd_in &lt;dbl&gt; 11.798817, 11.769870, 9.961764, 8.483428, … ## $ stand_qmd_in &lt;dbl&gt; 11.35364, 11.35364, 11.35364, 11.35364, 11… ## $ mean_tree_height_ft &lt;dbl&gt; 48.67188, 49.43520, 43.01832, 39.37591, 53… ## $ loreys_height_ft &lt;dbl&gt; 56.33383, 54.51146, 47.71008, 40.29876, 58… ## $ basal_area_ft2_per_ac &lt;dbl&gt; 4.2767553, 4.7482883, 1.2994531, 0.7117248… ## $ stand_basal_area_ft2_per_ac &lt;dbl&gt; 12.22562, 12.22562, 12.22562, 12.22562, 12… ## $ trees_per_ac &lt;dbl&gt; 3.9188010, 4.5944563, 1.8467913, 1.2161796… ## $ stand_trees_per_ac &lt;dbl&gt; 12.4771, 12.4771, 12.4771, 12.4771, 12.4771 ## $ stand_area_ac &lt;dbl&gt; 22.21743, 22.21743, 22.21743, 22.21743, 22… ## $ clump_area_ac &lt;dbl&gt; 0.6075555, 0.5722227, 0.1892662, 0.1131264… ## $ basal_area_ft2 &lt;dbl&gt; 94.95597, 105.42533, 28.85151, 15.80229, 2… ## $ stand_basal_area_ft2 &lt;dbl&gt; 271.4431, 271.4431, 271.4431, 271.4431, 27… target_data_temp %&gt;% dplyr::select( clump_n_trees_grp , tidyselect::starts_with(&quot;pct_stand_n_trees&quot;) , tidyselect::starts_with(&quot;trees_per_acre_&quot;) ) %&gt;% dplyr::left_join( clump_n_trees_grp_summary_temp2 %&gt;% dplyr::select(clump_n_trees_grp, pct_stand_n_trees, trees_per_ac) %&gt;% dplyr::rename( pct_stand_n_trees_presc = pct_stand_n_trees , trees_per_acre_presc = trees_per_ac ) , by = &quot;clump_n_trees_grp&quot; ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::where(is.numeric) , ~ dplyr::coalesce(.x,0) ) ) %&gt;% dplyr::relocate( pct_stand_n_trees_presc , .after = pct_stand_n_trees_target ) %&gt;% dplyr::relocate( trees_per_acre_presc , .after = trees_per_acre_target ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;pct_stand_n_trees&quot;) , ~ scales::percent(.x,accuracy = 1) ) ) %&gt;% kableExtra::kable( caption = paste0( &quot;Current stand BA (ft2/ac): &quot; , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand QMD (in): &quot; , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand TPA: &quot; , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %&gt;% scales::number(accuracy = 1) ) , escape = F , digits = 1 , col.names = c( &quot;&quot;, rep(c(&quot;current&quot;,&quot;target&quot;,&quot;prescription&quot;),2) ) ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::add_header_above( c(&quot; &quot;=1,&quot;% Trees&quot;=3, &quot;TPA&quot;=3) ) Table 3.7: Table 3.8: Current stand BA (ft2/ac): 15.8Current stand QMD (in): 10.6Current stand TPA: 18 % Trees TPA current target prescription current target prescription Individual 17% 30% 31% 3.1 3.9 3.9 2-4 trees 33% 40% 37% 6.0 5.2 4.6 5-9 trees 21% 15% 15% 3.9 2.0 1.8 10-15 trees 10% 10% 10% 1.9 1.3 1.2 16-25 trees 19% 5% 7% 3.5 0.7 0.9 &gt;25 trees 0% 0% 0% 0.0 0.0 0.0 check the pre- and post-treatment summary # call it clump_n_trees_grp_summary_temp2 = get_clump_n_trees_grp_summary( trees = ttops_temp2 , clumps = clump_polys_temp2 ) # table it clump_n_trees_grp_summary_temp2 %&gt;% dplyr::mutate(presc = &quot;post-treatment&quot;) %&gt;% dplyr::bind_rows( clump_n_trees_grp_summary_temp %&gt;% dplyr::mutate(presc = &quot;pre-treatment&quot;) ) %&gt;% dplyr::arrange(clump_n_trees_grp, desc(presc)) %&gt;% dplyr::select( clump_n_trees_grp, presc , n_trees , mean_dbh_in , qmd_in , mean_tree_height_ft , loreys_height_ft , trees_per_ac , basal_area_ft2_per_ac, pct_stand_basal_area, pct_stand_n_trees ) %&gt;% dplyr::mutate( dplyr::across( .cols = c(pct_stand_basal_area, pct_stand_n_trees) , .fns = ~ scales::percent(.x, accuracy = 1) ) ) %&gt;% kableExtra::kbl( digits = 1 , escape = F , caption = &quot;Pre- and Post-treatment overstory tree clump summary&quot; , col.names = c( &quot;.&quot;, &quot;&quot; , &quot;trees&quot; , &quot;mean&lt;br&gt;DBH (in)&quot; , &quot;QMD (in)&quot; , &quot;mean&lt;br&gt;Ht. (ft)&quot; , &quot;Loreys&lt;br&gt;Ht. (ft)&quot; , &quot;TPA&quot; , &quot;BA&lt;br&gt;ft&lt;sup&gt;2&lt;/sup&gt; ac&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;%&lt;br&gt;stand BA&quot; , &quot;%&lt;br&gt;stand trees&quot; ) ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;top&quot;) Table 3.9: Pre- and Post-treatment overstory tree clump summary . trees meanDBH (in) QMD (in) meanHt. (ft) LoreysHt. (ft) TPA BAft2 ac-1 %stand BA %stand trees Individual pre-treatment 68 11.0 11.7 47.9 57.1 3.1 3.2 21% 17% post-treatment 87 11.2 11.8 48.7 56.3 3.9 4.3 35% 31% 2-4 trees pre-treatment 134 10.6 11.0 46.8 52.4 6.0 5.6 35% 33% post-treatment 102 11.4 11.8 49.4 54.5 4.6 4.7 39% 37% 5-9 trees pre-treatment 86 9.7 10.1 43.4 49.1 3.9 2.9 19% 21% post-treatment 41 9.6 10.0 43.0 47.7 1.8 1.3 11% 15% 10-15 trees pre-treatment 42 8.0 8.2 37.9 39.5 1.9 1.0 7% 10% post-treatment 27 8.4 8.5 39.4 40.3 1.2 0.7 6% 10% 16-25 trees pre-treatment 77 10.4 10.8 46.1 50.8 3.5 3.0 19% 19% post-treatment 20 12.7 13.1 53.6 58.4 0.9 1.2 10% 7% "],["silv.html", "Section 4 Silvicultural Metrics 4.1 Stand Summary Metrics 4.2 DBH Distrubtion 4.3 Height Distribution", " Section 4 Silvicultural Metrics Overstory metrics are calculated using the UAS SfM-derived DBH and height measurements, where DBH is estimated using a local DBH-Height allometric relationship. In the following analysis and reporting, overstory includes any tree where the DBH is 6.0 in. (15.24 cm) or greater. Understory includes any tree where the DBH is less than 6.0 in. (15.24 cm) or greater. # Common silvicultural metrics are calculated for the entire extent. # Note, that stand-level summaries can be computed if stand vector data is provided. # metrics include: # &quot;n_trees&quot; # &quot;stand_area_ha&quot; # &quot;trees_per_ha&quot; # &quot;mean_dbh_cm&quot; # &quot;qmd_cm&quot; # &quot;mean_tree_height_m&quot; # &quot;loreys_height_m&quot; # &quot;basal_area_m2&quot; # &quot;basal_area_m2_per_ha&quot; # filter trees based on stand area harvests_trees = stand_sf %&gt;% dplyr::mutate( stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() , stand_area_ha = stand_area_m2/10000 , suid = &quot;1&quot; ) %&gt;% dplyr::select( suid, stand_area_m2, stand_area_ha ) %&gt;% sf::st_intersection(treetops_sf_with_dbh) ### stand-level summaries silv_metrics = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% # dplyr::filter(dbh_cm &gt;= ostory_dbh_cm) %&gt;% dplyr::ungroup() %&gt;% dplyr::group_by(suid,stand_area_ha) %&gt;% dplyr::summarise( n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( trees_per_ha = (n_trees/stand_area_ha) , basal_area_m2_per_ha = (basal_area_m2/stand_area_ha) , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units calc_imperial_units_fn() %&gt;% dplyr::select( &quot;suid&quot; , &quot;n_trees&quot; , &quot;stand_area_ha&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2&quot; , &quot;basal_area_m2_per_ha&quot; # imperial , &quot;stand_area_ac&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2&quot; , &quot;basal_area_ft2_per_ac&quot; ) ### export tabular write.csv( silv_metrics , paste0(delivery_dir, &quot;/stand_silv_metrics.csv&quot;) , row.names = F ) tab_met_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2_per_ha&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;basal_area_m2_per_ha&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ha)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ha^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $m^{2} \\\\cdot ha^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = paste0( &quot;Silvicultural Metrics (metric)&quot; # , &quot;\\nOverstory (&gt;= &quot; # , scales::comma(ostory_dbh_cm,accuracy = 0.1) # , &quot; cm DBH)&quot; ) , face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_met_fn(1) tab_imp_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2_per_ac&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;basal_area_ft2_per_ac&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ac)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = paste0( &quot;Silvicultural Metrics (imperial)&quot; # , &quot;\\nOverstory (&gt;= &quot; # , scales::comma(ostory_dbh_cm/2.54,accuracy = 0.1) # , &quot; in. DBH)&quot; ) , face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_imp_fn(1) 4.1 Stand Summary Metrics tab_imp_fn(1) + tab_met_fn(1) # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/silv_metrics.jpeg&quot;), dpi = &quot;print&quot;, height = 3.5, width = 6, device = &quot;jpeg&quot;) 4.2 DBH Distrubtion dbh_temp = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;&quot; , title = &quot;SfM-derived tree DBH distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + scale_y_continuous(breaks = NULL) + theme_light() + theme( legend.position = &quot;none&quot; ) dbh_temp tpa_temp = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in, stand_area_ha) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% dplyr::mutate( dbh_cl = ggplot2::cut_width(dbh_in, width = 1, center = 0.5, closed = &quot;left&quot;) ) %&gt;% dplyr::group_by(dbh_cl) %&gt;% dplyr::summarise( n_trees = dplyr::n() , trees_per_ac = dplyr::n()/max(stand_area_ha %&gt;% `*`(2.471)) , trees_per_ha = dplyr::n()/max(stand_area_ha) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( tot_trees_per_ac = sum(trees_per_ac) , tot_trees_per_ha = sum(trees_per_ha) , pct = trees_per_ac/tot_trees_per_ac , dbh_cl_lab = paste0( stringr::word(dbh_cl, 1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number() , &quot; to &quot; , stringr::word(dbh_cl, -1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number() %&gt;% `-`(0.1) ) %&gt;% factor() %&gt;% forcats::fct_reorder(stringr::word(dbh_cl, 1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number()) ) # plot tpa_temp %&gt;% ggplot( mapping = aes( x = dbh_cl_lab, y = trees_per_ac , fill=trees_per_ac , label = paste0( scales::comma(trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col(width = 0.7) + geom_text(color = &quot;black&quot;, size = 3, vjust = -0.2) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_y_continuous(labels = scales::comma_format(accuracy = 1),expand = expansion(mult = c(0, .13))) + labs( x = &quot;DBH (in) Class&quot; , y = &quot;TPA&quot; , title = &quot;Trees Per Acre by Diameter Class&quot; , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp$tot_trees_per_ac[1], accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, size = 10, face = &quot;bold&quot;, vjust = 0.5, hjust = 1) ) # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/tpa_dbh.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 10.5, device = &quot;jpeg&quot;) 4.3 Height Distribution ht_temp = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;&quot; , title = &quot;SfM-derived tree height distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + scale_y_continuous(breaks = NULL) + theme_light() + theme( legend.position = &quot;none&quot; ) ht_temp height + DBH ht_temp + dbh_temp # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/ht_dbh_dist.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 10.5, device = &quot;jpeg&quot;) ggplot(data = harvests_trees, mapping = aes(y = dbh_in, x = tree_height_ft)) + geom_point(size = 3, alpha = 0.8, color = &quot;firebrick&quot;) + scale_y_continuous(limits = c(0,NA), breaks = scales::extended_breaks(6)) + scale_x_continuous(limits = c(0,NA), breaks = scales::extended_breaks(15)) + labs( title = &quot;SfM-derived tree DBH modeled by tree height&quot; , x = &quot;Height (ft)&quot; , y = &quot;DBH (in)&quot; ) + theme_light() # save it ggplot2::ggsave(paste0(delivery_dir, &quot;/ht_dbh_relationship.jpeg&quot;), dpi = &quot;print&quot;, height = 7, width = 10.5, device = &quot;jpeg&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
